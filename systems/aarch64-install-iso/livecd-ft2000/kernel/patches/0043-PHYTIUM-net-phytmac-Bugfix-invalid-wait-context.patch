From b457489664fe84c98262242ff7769aabc8bf090c Mon Sep 17 00:00:00 2001
From: Li Wencheng <liwencheng@phytium.com.cn>
Date: Wed, 7 May 2025 17:22:13 +0800
Subject: [PATCH 43/67] PHYTIUM: net/phytmac: Bugfix invalid wait context

After the spinlock is called, the mutex should no longer to be
invoked, which will lead to unnecessary sleep.

Signed-off-by: Li Wencheng <liwencheng@phytium.com.cn>
Signed-off-by: Wang Yinfeng <wangyinfeng@phytium.com.cn>
Change-Id: I325188e12bdf0674454aba238624d05e4d877d38

Link: https://gitee.com/phytium_embedded/phytium-linux-kernel/commit/d35f06971ac92e652e17033d40067c58e0cfd90c
Signed-off-by: Kexy Biscuit <kexybiscuit@aosc.io>
---
 drivers/net/ethernet/phytium/phytmac.h      |  6 ++----
 drivers/net/ethernet/phytium/phytmac_main.c |  6 +-----
 drivers/net/ethernet/phytium/phytmac_v2.c   | 10 ++++------
 3 files changed, 7 insertions(+), 15 deletions(-)

diff --git a/drivers/net/ethernet/phytium/phytmac.h b/drivers/net/ethernet/phytium/phytmac.h
index e8a640de47a6..7acfc97d3fc2 100644
--- a/drivers/net/ethernet/phytium/phytmac.h
+++ b/drivers/net/ethernet/phytium/phytmac.h
@@ -434,8 +434,8 @@ struct phytmac_msg {
 	u32			tx_msg_rd_tail;
 	u32			rx_msg_head;
 	u32			rx_msg_tail;
-	/*use msg_mutex to protect msg */
-	struct mutex		msg_mutex;
+	/*use msg_lock to protect msg */
+	spinlock_t			msg_lock;
 };

 struct ts_ctrl {
@@ -473,8 +473,6 @@ struct phytmac {
 	struct work_struct		restart_task;
 	/* Lock to protect mac config */
 	spinlock_t			lock;
-	/* Lock to protect msg tx */
-	spinlock_t			msg_lock;
 	u32				rx_ring_size;
 	u32				tx_ring_size;
 	u32				dma_data_width;
diff --git a/drivers/net/ethernet/phytium/phytmac_main.c b/drivers/net/ethernet/phytium/phytmac_main.c
index df0aea0de7a4..765b01503c1f 100644
--- a/drivers/net/ethernet/phytium/phytmac_main.c
+++ b/drivers/net/ethernet/phytium/phytmac_main.c
@@ -2725,8 +2725,6 @@ int phytmac_drv_probe(struct phytmac *pdata)
 	if (hw_if->init_msg_ring)
 		hw_if->init_msg_ring(pdata);

-	mutex_init(&pdata->msg_ring.msg_mutex);
-
 	if (pdata->use_mii && !pdata->mii_bus) {
 		ret = phytmac_mdio_register(pdata);
 		if (ret) {
@@ -2793,8 +2791,6 @@ int phytmac_drv_remove(struct phytmac *pdata)

 		if (pdata->phylink)
 			phylink_destroy(pdata->phylink);
-
-		mutex_destroy(&pdata->msg_ring.msg_mutex);
 	}

 	return 0;
@@ -2904,7 +2900,7 @@ struct phytmac *phytmac_alloc_pdata(struct device *dev)
 	pdata->dev = dev;

 	spin_lock_init(&pdata->lock);
-	spin_lock_init(&pdata->msg_lock);
+	spin_lock_init(&pdata->msg_ring.msg_lock);
 	spin_lock_init(&pdata->ts_clk_lock);
 	pdata->msg_enable = netif_msg_init(debug, PHYTMAC_DEFAULT_MSG_ENABLE);

diff --git a/drivers/net/ethernet/phytium/phytmac_v2.c b/drivers/net/ethernet/phytium/phytmac_v2.c
index e43a55fe4770..65db2c0d15de 100644
--- a/drivers/net/ethernet/phytium/phytmac_v2.c
+++ b/drivers/net/ethernet/phytium/phytmac_v2.c
@@ -27,7 +27,7 @@ static int phytmac_v2_msg_send(struct phytmac *pdata, u16 cmd_id,
 	struct phytmac_msg_info msg_rx;
 	int ret = 0;

-	mutex_lock(&pdata->msg_ring.msg_mutex);
+	spin_lock(&pdata->msg_ring.msg_lock);
 	tx_head = PHYTMAC_READ(pdata, PHYTMAC_TX_MSG_HEAD) & 0xff;
 	tx_tail = phytmac_v2_tx_ring_wrap(pdata, pdata->msg_ring.tx_msg_wr_tail);
 	pdata->msg_ring.tx_msg_rd_tail = tx_tail;
@@ -36,7 +36,6 @@ static int phytmac_v2_msg_send(struct phytmac *pdata, u16 cmd_id,
 	while ((tx_tail + 1) % ring_size == tx_head) {
 		netdev_info(pdata->ndev, "Tx msg ring is overrun, tx_tail:0x%x, tx_head:0x%x",
 			    tx_tail, tx_head);
-		cpu_relax();
 		tx_head = PHYTMAC_READ(pdata, PHYTMAC_TX_MSG_HEAD) & 0xff;
 	}

@@ -50,7 +49,7 @@ static int phytmac_v2_msg_send(struct phytmac *pdata, u16 cmd_id,
 	} else if (len > PHYTMAC_MSG_PARA_LEN) {
 		netdev_err(pdata->ndev, "Tx msg para len %d is greater than the max len %d",
 			   len, PHYTMAC_MSG_PARA_LEN);
-		mutex_unlock(&pdata->msg_ring.msg_mutex);
+		spin_unlock(&pdata->msg_ring.msg_lock);
 		return -EINVAL;
 	}

@@ -67,7 +66,6 @@ static int phytmac_v2_msg_send(struct phytmac *pdata, u16 cmd_id,
 	if (wait) {
 		tx_head = PHYTMAC_READ(pdata, PHYTMAC_TX_MSG_HEAD) & 0xff;
 		while (tx_head != tx_tail) {
-			cpu_relax();
 			tx_head = PHYTMAC_READ(pdata, PHYTMAC_TX_MSG_HEAD) & 0xff;
 		}

@@ -76,12 +74,12 @@ static int phytmac_v2_msg_send(struct phytmac *pdata, u16 cmd_id,
 		if (!(msg_rx.status0 & PHYTMAC_CMD_PRC_SUCCESS)) {
 			netdev_err(pdata->ndev, "Msg process error, cmdid:%d, subid:%d, status0:%d, tail:%d",
 				   msg.cmd_type, msg.cmd_subid, msg.status0, tx_tail);
-			mutex_unlock(&pdata->msg_ring.msg_mutex);
+			spin_unlock(&pdata->msg_ring.msg_lock);
 			return -EINVAL;
 		}
 	}

-	mutex_unlock(&pdata->msg_ring.msg_mutex);
+	spin_unlock(&pdata->msg_ring.msg_lock);
 	return ret;
 }

--
2.50.1
