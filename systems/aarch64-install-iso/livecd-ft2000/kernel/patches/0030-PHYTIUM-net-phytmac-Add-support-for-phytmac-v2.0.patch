From ed56da88aba1e2c82833b497b580935d998b20ca Mon Sep 17 00:00:00 2001
From: Li Wencheng <liwencheng@phytium.com.cn>
Date: Thu, 15 Aug 2024 17:06:59 +0800
Subject: [PATCH 30/67] PHYTIUM: net/phytmac: Add support for phytmac v2.0

This patch Adds support for phtymac v2.0,including acpi description,
rx tail pointer supporting, power management and other functions.

Mainline: NA
Signed-off-by: Li Wencheng <liwencheng@phytium.com.cn>
Signed-off-by: Wang Yinfeng <wangyinfeng@phytium.com.cn>
Change-Id: I4758cfb98004683e6ea79079ec263fbc49e46c69

Link: https://gitee.com/phytium_embedded/phytium-linux-kernel/commit/3f2b924070a4f3937eef439656d0971eaaa2aa14
Signed-off-by: Kexy Biscuit <kexybiscuit@aosc.io>
---
 drivers/net/ethernet/phytium/Makefile         |   2 +-
 drivers/net/ethernet/phytium/phytmac.h        |  57 +-
 .../net/ethernet/phytium/phytmac_ethtool.c    |   1 +
 drivers/net/ethernet/phytium/phytmac_main.c   | 104 ++-
 drivers/net/ethernet/phytium/phytmac_pci.c    |   4 +-
 .../net/ethernet/phytium/phytmac_platform.c   | 147 ++++-
 drivers/net/ethernet/phytium/phytmac_ptp.c    |   3 +
 drivers/net/ethernet/phytium/phytmac_ptp.h    |   1 +
 drivers/net/ethernet/phytium/phytmac_v1.c     | 118 +++-
 drivers/net/ethernet/phytium/phytmac_v1.h     |  19 +-
 drivers/net/ethernet/phytium/phytmac_v2.c     | 606 +++++++++++-------
 drivers/net/ethernet/phytium/phytmac_v2.h     |  74 ++-
 12 files changed, 796 insertions(+), 340 deletions(-)

diff --git a/drivers/net/ethernet/phytium/Makefile b/drivers/net/ethernet/phytium/Makefile
index 6e710d4d54b6..debaed63e453 100644
--- a/drivers/net/ethernet/phytium/Makefile
+++ b/drivers/net/ethernet/phytium/Makefile
@@ -1,9 +1,9 @@

 # SPDX-License-Identifier: GPL-2.0
+# Copyright(c) 2022 - 2025 Phytium Technology Co., Ltd.
 #
 # Makefile for the Phytium network device drivers.
 #
-#

 obj-$(CONFIG_PHYTMAC) += phytmac.o

diff --git a/drivers/net/ethernet/phytium/phytmac.h b/drivers/net/ethernet/phytium/phytmac.h
index df4ec49a0851..3806e09bc122 100644
--- a/drivers/net/ethernet/phytium/phytmac.h
+++ b/drivers/net/ethernet/phytium/phytmac.h
@@ -1,4 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
+/* Copyright(c) 2022 - 2025 Phytium Technology Co., Ltd. */
+
 #ifndef _PHYTMAC_H
 #define _PHYTMAC_H

@@ -13,7 +15,7 @@

 #define PHYTMAC_DRV_NAME		"phytium-mac"
 #define PHYTMAC_DRV_DESC		"PHYTIUM Ethernet Driver"
-#define PHYTMAC_DRIVER_VERSION		"1.0.5"
+#define PHYTMAC_DRIVER_VERSION		"1.0.29"
 #define PHYTMAC_DEFAULT_MSG_ENABLE	  \
 		(NETIF_MSG_DRV		| \
 		NETIF_MSG_PROBE	| \
@@ -44,6 +46,8 @@

 #define PHYTMAC_POWEROFF	1
 #define PHYTMAC_POWERON		2
+#define PHYTMAC_PWCTL_GMAC_ID		6
+#define PHYTMAC_PWCTL_DEFAULT_VAL	0

 #define PHYTMAC_WOL_MAGIC_PACKET	1

@@ -58,8 +62,12 @@
 #define PHYTMAC_CAPS_TAILPTR			0x00000040
 #define PHYTMAC_CAPS_START			0x00000080
 #define PHYTMAC_CAPS_NO_WOL			0x0000100
-#define PHYTMAC_CAPS_LPI			0x0000400
+#define PHYTMAC_CAPS_PWCTRL			0x0000200
 #define PHYTMAC_CAPS_MSG			0x0000800
+#define PHYTMAC_CAPS_RXPTR			0x0001000
+
+#define VERSION_V0			0
+#define VERSION_V3			0x3

 #define PHYTMAC_TX			0x1
 #define PHYTMAC_RX			0x2
@@ -122,6 +130,39 @@
 #define PHYTMAC_WAKE_UCAST		0x00000004
 #define PHYTMAC_WAKE_MCAST		0x00000008

+enum phytmac_interface {
+	PHYTMAC_PHY_INTERFACE_MODE_NA,
+	PHYTMAC_PHY_INTERFACE_MODE_INTERNAL,
+	PHYTMAC_PHY_INTERFACE_MODE_MII,
+	PHYTMAC_PHY_INTERFACE_MODE_GMII,
+	PHYTMAC_PHY_INTERFACE_MODE_SGMII,
+	PHYTMAC_PHY_INTERFACE_MODE_TBI,
+	PHYTMAC_PHY_INTERFACE_MODE_REVMII,
+	PHYTMAC_PHY_INTERFACE_MODE_RMII,
+	PHYTMAC_PHY_INTERFACE_MODE_RGMII,
+	PHYTMAC_PHY_INTERFACE_MODE_RGMII_ID,
+	PHYTMAC_PHY_INTERFACE_MODE_RGMII_RXID,
+	PHYTMAC_PHY_INTERFACE_MODE_RGMII_TXID,
+	PHYTMAC_PHY_INTERFACE_MODE_RTBI,
+	PHYTMAC_PHY_INTERFACE_MODE_SMII,
+	PHYTMAC_PHY_INTERFACE_MODE_XGMII,
+	PHYTMAC_PHY_INTERFACE_MODE_MOCA,
+	PHYTMAC_PHY_INTERFACE_MODE_QSGMII,
+	PHYTMAC_PHY_INTERFACE_MODE_TRGMII,
+	PHYTMAC_PHY_INTERFACE_MODE_100BASEX,
+	PHYTMAC_PHY_INTERFACE_MODE_1000BASEX,
+	PHYTMAC_PHY_INTERFACE_MODE_2500BASEX,
+	PHYTMAC_PHY_INTERFACE_MODE_5GBASER,
+	PHYTMAC_PHY_INTERFACE_MODE_RXAUI,
+	PHYTMAC_PHY_INTERFACE_MODE_XAUI,
+	/* 10GBASE-R, XFI, SFI - single lane 10G Serdes */
+	PHYTMAC_PHY_INTERFACE_MODE_10GBASER,
+	PHYTMAC_PHY_INTERFACE_MODE_USXGMII,
+	/* 10GBASE-KR - with Clause 73 AN */
+	PHYTMAC_PHY_INTERFACE_MODE_10GKR,
+	PHYTMAC_PHY_INTERFACE_MODE_MAX,
+};
+
 struct packet_info {
 	int lso;
 	int desc_cnt;
@@ -214,7 +255,6 @@ static const struct phytmac_statistics queue_statistics[] = {
 struct phytmac_config {
 	struct	phytmac_hw_if *hw_if;
 	u32	caps;
-	u32	tsu_rate;
 	u16	queue_num;
 };

@@ -367,8 +407,8 @@ struct phytmac_msg {
 	u32			tx_msg_tail;
 	u32			rx_msg_head;
 	u32			rx_msg_tail;
-	/* Lock to protect msg */
-	spinlock_t		msg_lock;
+	/*use msg_mutex to protect msg */
+	struct mutex		msg_mutex;
 };

 struct ts_ctrl {
@@ -401,7 +441,6 @@ struct phytmac {
 	u32				min_tx_length;
 	u32				jumbo_len;
 	u32				wol;
-	u32				lpi;
 	u32				power_state;
 	struct work_struct		restart_task;
 	/* Lock to protect mac config */
@@ -430,6 +469,7 @@ struct phytmac {
 	struct phylink_pcs		phylink_pcs;
 	int				pause;
 	phy_interface_t			phy_interface;
+	enum phytmac_interface	phytmac_v2_interface;
 	int				speed;
 	int				duplex;
 	int				autoneg;
@@ -446,6 +486,7 @@ struct phytmac {
 	/* Lock to protect fs */
 	spinlock_t			rx_fs_lock;
 	unsigned int			max_rx_fs;
+	u32						version;
 };

 struct phytmac_hw_if {
@@ -507,7 +548,7 @@ struct phytmac_hw_if {
 	void (*init_rx_map)(struct phytmac_queue *queue, u32 index);
 	unsigned int (*rx_map)(struct phytmac_queue *queue, u32 index, dma_addr_t addr);
 	void (*transmit)(struct phytmac_queue *queue);
-	void (*restart)(struct phytmac *pdata);
+	void (*update_rx_tail)(struct phytmac_queue *queue);
 	int (*tx_complete)(const struct phytmac_dma_desc *desc);
 	bool (*rx_complete)(const struct phytmac_dma_desc *desc);
 	int (*get_rx_pkt_len)(struct phytmac *pdata, const struct phytmac_dma_desc *desc);
@@ -517,6 +558,7 @@ struct phytmac_hw_if {
 	bool (*rx_pkt_start)(const struct phytmac_dma_desc *desc);
 	bool (*rx_pkt_end)(const struct phytmac_dma_desc *desc);
 	unsigned int (*zero_rx_desc_addr)(struct phytmac_dma_desc *desc);
+	unsigned int (*zero_tx_desc)(struct phytmac_dma_desc *desc);
 	void (*clear_rx_desc)(struct phytmac_queue *queue, int begin, int end);
 	void (*clear_tx_desc)(struct phytmac_queue *queue);
 	/* ptp */
@@ -604,6 +646,7 @@ int phytmac_drv_probe(struct phytmac *pdata);
 int phytmac_drv_remove(struct phytmac *pdata);
 int phytmac_drv_suspend(struct phytmac *pdata);
 int phytmac_drv_resume(struct phytmac *pdata);
+void phytmac_drv_shutdown(struct phytmac *pdata);
 struct phytmac *phytmac_alloc_pdata(struct device *dev);
 void phytmac_free_pdata(struct phytmac *pdata);
 int phytmac_reset_ringsize(struct phytmac *pdata, u32 rx_size, u32 tx_size);
diff --git a/drivers/net/ethernet/phytium/phytmac_ethtool.c b/drivers/net/ethernet/phytium/phytmac_ethtool.c
index e1698fa10b09..e05274b961e4 100644
--- a/drivers/net/ethernet/phytium/phytmac_ethtool.c
+++ b/drivers/net/ethernet/phytium/phytmac_ethtool.c
@@ -1,4 +1,5 @@
 // SPDX-License-Identifier: GPL-2.0-only
+/* Copyright(c) 2022 - 2025 Phytium Technology Co., Ltd. */

 #include <linux/ethtool.h>
 #include <linux/phy.h>
diff --git a/drivers/net/ethernet/phytium/phytmac_main.c b/drivers/net/ethernet/phytium/phytmac_main.c
index fd29c647e277..dcede058512c 100644
--- a/drivers/net/ethernet/phytium/phytmac_main.c
+++ b/drivers/net/ethernet/phytium/phytmac_main.c
@@ -2,6 +2,8 @@
 /*
  * Phytium Ethernet Controller driver
  *
+ * Copyright(c) 2022 - 2025 Phytium Technology Co., Ltd.
+ *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
  * published by the Free Software Foundation.
@@ -125,10 +127,12 @@ static int phytmac_get_mac_address(struct phytmac *pdata)

 	if (is_valid_ether_addr(addr)) {
 		eth_hw_addr_set(pdata->ndev, addr);
+		ether_addr_copy(pdata->ndev->perm_addr, addr);
 		return 0;
 	}
 	dev_info(pdata->dev, "invalid hw address, using random\n");
 	eth_hw_addr_random(pdata->ndev);
+	ether_addr_copy(pdata->ndev->perm_addr, pdata->ndev->dev_addr);

 	return 0;
 }
@@ -1033,6 +1037,8 @@ static void phytmac_rx_clean(struct phytmac_queue *queue)
 	queue->rx_next_to_alloc = queue->rx_head;
 	/* make newly descriptor to hardware */
 	wmb();
+
+	hw_if->update_rx_tail(queue);
 }

 static int phytmac_rx(struct phytmac_queue *queue, struct napi_struct *napi,
@@ -1143,7 +1149,7 @@ static int phytmac_tx_clean(struct phytmac_queue *queue, int budget)
 	unsigned int tail = queue->tx_tail;
 	unsigned int head;

-	spin_lock(&pdata->lock);
+	spin_lock(&queue->tx_lock);

 	for (head = queue->tx_head; head != tail && packet_count < budget; ) {
 		struct sk_buff *skb;
@@ -1180,7 +1186,7 @@ static int phytmac_tx_clean(struct phytmac_queue *queue, int budget)
 				packet_count++;
 			}

-			  /* Now we can safely release resources */
+			/* Now we can safely release resources */
 			phytmac_tx_unmap(pdata, tx_skb, budget);

 			if (complete) {
@@ -1198,7 +1204,7 @@ static int phytmac_tx_clean(struct phytmac_queue *queue, int budget)
 	if (__netif_subqueue_stopped(pdata->ndev, queue_index) &&
 	    (phytmac_maybe_wake_tx_queue(queue)))
 		netif_wake_subqueue(pdata->ndev, queue_index);
-	spin_unlock(&pdata->lock);
+	spin_unlock(&queue->tx_lock);

 	return packet_count;
 }
@@ -1281,6 +1287,7 @@ static inline int phytmac_clear_csum(struct sk_buff *skb)

 static int phytmac_add_fcs(struct sk_buff **skb, struct net_device *ndev)
 {
+#ifdef PHYTMAC_SW_FCS
 	bool cloned = skb_cloned(*skb) || skb_header_cloned(*skb) ||
 				  skb_is_nonlinear(*skb);
 	int padlen = ETH_ZLEN - (*skb)->len;
@@ -1290,7 +1297,7 @@ static int phytmac_add_fcs(struct sk_buff **skb, struct net_device *ndev)
 	u32 fcs;
 	int i;

-	if ((ndev->features & NETIF_F_HW_CSUM) ||
+	if (!(ndev->features & NETIF_F_HW_CSUM) ||
 	    !((*skb)->ip_summed != CHECKSUM_PARTIAL) ||
 	    skb_shinfo(*skb)->gso_size || phytmac_ptp_one_step(*skb))
 		return 0;
@@ -1327,6 +1334,8 @@ static int phytmac_add_fcs(struct sk_buff **skb, struct net_device *ndev)

 	for (i = 0; i < 4; ++i)
 		skb_put_u8(*skb, (fcs >> (i * 8)) & 0xff);
+#endif
+
 	return 0;
 }

@@ -1376,13 +1385,13 @@ static int phytmac_packet_info(struct phytmac *pdata,
 		desc_cnt += TXD_USE_COUNT(pdata, skb_frag_size(&skb_shinfo(skb)->frags[f]));
 	packet->desc_cnt = desc_cnt;

-	if ((!(pdata->ndev->features & NETIF_F_HW_CSUM)) &&
+#ifdef PHYTMAC_SW_FCS
+	if ((pdata->ndev->features & NETIF_F_HW_CSUM) &&
 	    skb->ip_summed != CHECKSUM_PARTIAL &&
 	    !is_lso &&
 	    !phytmac_ptp_one_step(skb))
 		packet->nocrc = 1;
-	else
-		packet->nocrc = 0;
+#endif

 	if (netif_msg_pktdata(pdata)) {
 		netdev_info(pdata->ndev, "packet info: desc_cnt=%d, nocrc=%d,ip_summed=%d\n",
@@ -1522,7 +1531,6 @@ static netdev_tx_t phytmac_start_xmit(struct sk_buff *skb, struct net_device *nd
 	struct phytmac_queue *queue = &pdata->queues[queue_index];
 	netdev_tx_t ret = NETDEV_TX_OK;
 	struct packet_info packet;
-	unsigned long flags;

 	if (phytmac_clear_csum(skb)) {
 		dev_kfree_skb_any(skb);
@@ -1543,7 +1551,7 @@ static netdev_tx_t phytmac_start_xmit(struct sk_buff *skb, struct net_device *nd
 	if (netif_msg_pktdata(pdata))
 		phytmac_dump_pkt(pdata, skb, true);

-	spin_lock_irqsave(&pdata->lock, flags);
+	spin_lock_bh(&queue->tx_lock);
 	/* Check that there are enough descriptors available */
 	ret = phytmac_maybe_stop_tx_queue(queue, packet.desc_cnt);
 	if (ret)
@@ -1562,7 +1570,7 @@ static netdev_tx_t phytmac_start_xmit(struct sk_buff *skb, struct net_device *nd
 	hw_if->transmit(queue);

 tx_return:
-	spin_unlock_irqrestore(&pdata->lock, flags);
+	spin_unlock_bh(&queue->tx_lock);
 	return ret;
 }

@@ -1668,6 +1676,7 @@ static void phytmac_mac_link_down(struct phylink_config *config, unsigned int mo
 	unsigned int q;
 	unsigned long flags;
 	struct phytmac_tx_skb *tx_skb;
+	struct phytmac_dma_desc *tx_desc = NULL;
 	int i;

 	if (netif_msg_link(pdata)) {
@@ -1686,18 +1695,22 @@ static void phytmac_mac_link_down(struct phylink_config *config, unsigned int mo

 	/* Disable Rx and Tx */
 	hw_if->enable_network(pdata, false, PHYTMAC_RX | PHYTMAC_TX);
+	spin_unlock_irqrestore(&pdata->lock, flags);

 	/* Tx clean */
 	for (q = 0, queue = pdata->queues; q < pdata->queues_num; ++q, ++queue) {
+		spin_lock_bh(&queue->tx_lock);
 		for (i = 0; i < pdata->tx_ring_size; i++) {
 			tx_skb = phytmac_get_tx_skb(queue, i);
 			if (tx_skb)
 				phytmac_tx_unmap(pdata, tx_skb, 0);
+
+			tx_desc = phytmac_get_tx_desc(queue, i);
+			hw_if->zero_tx_desc(tx_desc);
 		}
+		spin_unlock_bh(&queue->tx_lock);
 	}

-	spin_unlock_irqrestore(&pdata->lock, flags);
-
 	netif_tx_stop_all_queues(ndev);
 }

@@ -1890,6 +1903,8 @@ static int phytmac_phylink_create(struct phytmac *pdata)

 	pdata->phylink_config.dev = &pdata->ndev->dev;
 	pdata->phylink_config.type = PHYLINK_NETDEV;
+	pdata->phylink_config.mac_managed_pm = true;
+
 	if (pdata->phy_interface == PHY_INTERFACE_MODE_SGMII ||
 	    pdata->phy_interface == PHY_INTERFACE_MODE_1000BASEX ||
 	    pdata->phy_interface == PHY_INTERFACE_MODE_2500BASEX ||
@@ -1923,10 +1938,6 @@ static int phytmac_open(struct net_device *ndev)
 	if (netif_msg_probe(pdata))
 		dev_dbg(pdata->dev, "open\n");

-	/* phytmac_powerup */
-	if (pdata->power_state == PHYTMAC_POWEROFF)
-		hw_if->poweron(pdata, PHYTMAC_POWERON);
-
 	if (hw_if->init_msg_ring)
 		hw_if->init_msg_ring(pdata);

@@ -2033,10 +2044,6 @@ static int phytmac_close(struct net_device *ndev)
 	if (IS_REACHABLE(CONFIG_PHYTMAC_ENABLE_PTP))
 		phytmac_ptp_unregister(pdata);

-	/* phytmac_powerup */
-	if (pdata->power_state == PHYTMAC_POWERON)
-		hw_if->poweron(pdata, PHYTMAC_POWEROFF);
-
 	return 0;
 }

@@ -2309,6 +2316,7 @@ int phytmac_drv_probe(struct phytmac *pdata)
 {
 	struct net_device *ndev = pdata->ndev;
 	struct device *dev = pdata->dev;
+	struct phytmac_hw_if *hw_if = pdata->hw_if;
 	int ret = 0;

 	if (netif_msg_probe(pdata))
@@ -2332,12 +2340,13 @@ int phytmac_drv_probe(struct phytmac *pdata)
 			goto err_out;
 	}

-	netif_carrier_off(ndev);
-	ret = register_netdev(ndev);
-	if (ret) {
-		dev_err(pdata->dev, "Cannot register net device, aborting.\n");
-		goto err_out;
-	}
+	if (pdata->power_state == PHYTMAC_POWEROFF)
+		hw_if->poweron(pdata, PHYTMAC_POWERON);
+
+	if (hw_if->init_msg_ring)
+		hw_if->init_msg_ring(pdata);
+
+	mutex_init(&pdata->msg_ring.msg_mutex);

 	if (pdata->use_mii && !pdata->mii_bus) {
 		ret = phytmac_mdio_register(pdata);
@@ -2359,6 +2368,13 @@ int phytmac_drv_probe(struct phytmac *pdata)
 		goto err_phylink_init;
 	}

+	ret = register_netdev(ndev);
+	if (ret) {
+		dev_err(pdata->dev, "Cannot register net device, aborting.\n");
+		goto err_phylink_init;
+	}
+	netif_carrier_off(ndev);
+
 	if (netif_msg_probe(pdata))
 		dev_dbg(pdata->dev, "probe successfully! Phytium %s at 0x%08lx irq %d (%pM)\n",
 			"MAC", ndev->base_addr, ndev->irq, ndev->dev_addr);
@@ -2373,8 +2389,6 @@ int phytmac_drv_probe(struct phytmac *pdata)
 	if (pdata->mii_bus)
 		mdiobus_free(pdata->mii_bus);

-	unregister_netdev(ndev);
-
 err_out:
 	return ret;
 }
@@ -2383,12 +2397,15 @@ EXPORT_SYMBOL_GPL(phytmac_drv_probe);
 int phytmac_drv_remove(struct phytmac *pdata)
 {
 	struct net_device *ndev = pdata->ndev;
+	struct phytmac_hw_if *hw_if = pdata->hw_if;

 	if (ndev) {
 		if (pdata->use_ncsi && pdata->ncsidev)
 			ncsi_unregister_dev(pdata->ncsidev);

 		unregister_netdev(ndev);
+		if (pdata->power_state == PHYTMAC_POWERON)
+			hw_if->poweron(pdata, PHYTMAC_POWEROFF);

 		if (pdata->use_mii && pdata->mii_bus) {
 			mdiobus_unregister(pdata->mii_bus);
@@ -2397,6 +2414,8 @@ int phytmac_drv_remove(struct phytmac *pdata)

 		if (pdata->phylink)
 			phylink_destroy(pdata->phylink);
+
+		mutex_destroy(&pdata->msg_ring.msg_mutex);
 	}

 	return 0;
@@ -2422,12 +2441,15 @@ int phytmac_drv_suspend(struct phytmac *pdata)
 	/* napi_disable */
 	for (q = 0, queue = pdata->queues; q < pdata->queues_num;
 	     ++q, ++queue) {
+		hw_if->disable_irq(pdata, queue->index, pdata->rx_irq_mask | pdata->tx_irq_mask);
+		hw_if->clear_irq(pdata, queue->index, pdata->rx_irq_mask | pdata->tx_irq_mask);
 		napi_disable(&queue->tx_napi);
 		napi_disable(&queue->rx_napi);
 	}

 	if (pdata->wol) {
 		hw_if->set_wol(pdata, pdata->wol);
+		pdata->power_state = PHYTMAC_POWEROFF;
 	} else {
 		rtnl_lock();
 		phylink_stop(pdata->phylink);
@@ -2449,15 +2471,14 @@ int phytmac_drv_resume(struct phytmac *pdata)
 	struct phytmac_hw_if *hw_if = pdata->hw_if;
 	struct ethtool_rx_fs_item *item;

-	if (!netif_running(pdata->ndev))
-		return 0;
-
-	if (pdata->power_state == PHYTMAC_POWEROFF)
-		hw_if->poweron(pdata, PHYTMAC_POWERON);
+	hw_if->poweron(pdata, PHYTMAC_POWERON);

 	if (hw_if->init_msg_ring)
 		hw_if->init_msg_ring(pdata);

+	if (!netif_running(pdata->ndev))
+		return 0;
+
 	if (pdata->wol) {
 		hw_if->set_wol(pdata, 0);
 		rtnl_lock();
@@ -2520,6 +2541,23 @@ void phytmac_free_pdata(struct phytmac *pdata)
 }
 EXPORT_SYMBOL_GPL(phytmac_free_pdata);

+void phytmac_drv_shutdown(struct phytmac *pdata)
+{
+	struct net_device *netdev = pdata->ndev;
+	struct phytmac_hw_if *hw_if = pdata->hw_if;
+
+	rtnl_lock();
+	netif_device_detach(netdev);
+
+	if (netif_running(netdev))
+		phytmac_close(netdev);
+	rtnl_unlock();
+
+	if (pdata->power_state == PHYTMAC_POWERON)
+		hw_if->poweron(pdata, PHYTMAC_POWEROFF);
+}
+EXPORT_SYMBOL_GPL(phytmac_drv_shutdown);
+
 MODULE_LICENSE("GPL");
 MODULE_DESCRIPTION("Phytium Ethernet driver");
 MODULE_AUTHOR("Wenting Song");
diff --git a/drivers/net/ethernet/phytium/phytmac_pci.c b/drivers/net/ethernet/phytium/phytmac_pci.c
index 60bd296d8f0b..62766c49d1a6 100644
--- a/drivers/net/ethernet/phytium/phytmac_pci.c
+++ b/drivers/net/ethernet/phytium/phytmac_pci.c
@@ -2,6 +2,9 @@
 /*
  * Phytium GMAC PCI wrapper.
  *
+ * Copyright(c) 2022 - 2025 Phytium Technology Co., Ltd.
+ *
+ * Author: Wenting Song <songwenting@phytium.com>
  */

 #include <linux/pci.h>
@@ -21,7 +24,6 @@
 struct phytmac_data {
 	struct phytmac_hw_if	*hw_if;
 	u32			caps;
-	u32			tsu_rate;
 	u16			queue_num;
 	int			speed;
 	bool			duplex;
diff --git a/drivers/net/ethernet/phytium/phytmac_platform.c b/drivers/net/ethernet/phytium/phytmac_platform.c
index 9390056fdc7a..95509711894b 100644
--- a/drivers/net/ethernet/phytium/phytmac_platform.c
+++ b/drivers/net/ethernet/phytium/phytmac_platform.c
@@ -2,6 +2,9 @@
 /*
  * Phytium GMAC Platform wrapper.
  *
+ * Copyright(c) 2022 - 2025 Phytium Technology Co., Ltd.
+ *
+ * Author: Wenting Song <songwenting@phytium.com>
  */

 #define pr_fmt(fmt) KBUILD_MODNAME ": " fmt
@@ -21,18 +24,17 @@ static const struct phytmac_config phytium_1p0_config = {
 			| PHYTMAC_CAPS_JUMBO
 			| PHYTMAC_CAPS_LSO,
 	.queue_num = 4,
-	.tsu_rate = 300000000,
 };

 static const struct phytmac_config phytium_2p0_config = {
 	.hw_if = &phytmac_2p0_hw,
 	.caps = PHYTMAC_CAPS_TAILPTR
-			| PHYTMAC_CAPS_LPI
+			| PHYTMAC_CAPS_RXPTR
+			| PHYTMAC_CAPS_PWCTRL
 			| PHYTMAC_CAPS_LSO
 			| PHYTMAC_CAPS_MSG
 			| PHYTMAC_CAPS_JUMBO,
 	.queue_num = 2,
-	.tsu_rate = 300000000,
 };

 #if defined(CONFIG_OF)
@@ -47,7 +49,8 @@ MODULE_DEVICE_TABLE(of, phytmac_dt_ids);
 #ifdef CONFIG_ACPI
 static const struct acpi_device_id phytmac_acpi_ids[] = {
 	{ .id = "PHYT0046", .driver_data = (kernel_ulong_t)&phytium_1p0_config },
-	{ }
+	{ .id = "PHYT0056", .driver_data = (kernel_ulong_t)&phytium_2p0_config },
+	{}
 };

 MODULE_DEVICE_TABLE(acpi, phytmac_acpi_ids);
@@ -55,6 +58,95 @@ MODULE_DEVICE_TABLE(acpi, phytmac_acpi_ids);
 #define phytmac_acpi_ids NULL
 #endif

+static const char *phytmac_phy_modes(enum phytmac_interface interface)
+{
+	switch (interface) {
+	case PHYTMAC_PHY_INTERFACE_MODE_NA:
+		return "";
+	case PHYTMAC_PHY_INTERFACE_MODE_INTERNAL:
+		return "internal";
+	case PHYTMAC_PHY_INTERFACE_MODE_MII:
+		return "mii";
+	case PHYTMAC_PHY_INTERFACE_MODE_GMII:
+		return "gmii";
+	case PHYTMAC_PHY_INTERFACE_MODE_SGMII:
+		return "sgmii";
+	case PHYTMAC_PHY_INTERFACE_MODE_TBI:
+		return "tbi";
+	case PHYTMAC_PHY_INTERFACE_MODE_REVMII:
+		return "rev-mii";
+	case PHYTMAC_PHY_INTERFACE_MODE_RMII:
+		return "rmii";
+	case PHYTMAC_PHY_INTERFACE_MODE_RGMII:
+		return "rgmii";
+	case PHYTMAC_PHY_INTERFACE_MODE_RGMII_ID:
+		return "rgmii-id";
+	case PHYTMAC_PHY_INTERFACE_MODE_RGMII_RXID:
+		return "rgmii-rxid";
+	case PHYTMAC_PHY_INTERFACE_MODE_RGMII_TXID:
+		return "rgmii-txid";
+	case PHYTMAC_PHY_INTERFACE_MODE_RTBI:
+		return "rtbi";
+	case PHYTMAC_PHY_INTERFACE_MODE_SMII:
+		return "smii";
+	case PHYTMAC_PHY_INTERFACE_MODE_XGMII:
+		return "xgmii";
+	case PHYTMAC_PHY_INTERFACE_MODE_MOCA:
+		return "moca";
+	case PHYTMAC_PHY_INTERFACE_MODE_QSGMII:
+		return "qsgmii";
+	case PHYTMAC_PHY_INTERFACE_MODE_TRGMII:
+		return "trgmii";
+	case PHYTMAC_PHY_INTERFACE_MODE_100BASEX:
+		return "100base-x";
+	case PHYTMAC_PHY_INTERFACE_MODE_1000BASEX:
+		return "1000base-x";
+	case PHYTMAC_PHY_INTERFACE_MODE_2500BASEX:
+		return "2500base-x";
+	case PHYTMAC_PHY_INTERFACE_MODE_5GBASER:
+		return "5gbase-r";
+	case PHYTMAC_PHY_INTERFACE_MODE_RXAUI:
+		return "rxaui";
+	case PHYTMAC_PHY_INTERFACE_MODE_XAUI:
+		return "xaui";
+	case PHYTMAC_PHY_INTERFACE_MODE_10GBASER:
+		return "10gbase-r";
+	case PHYTMAC_PHY_INTERFACE_MODE_USXGMII:
+		return "usxgmii";
+	case PHYTMAC_PHY_INTERFACE_MODE_10GKR:
+		return "10gbase-kr";
+	default:
+		return "unknown";
+	}
+}
+
+static int phytmac_v2_get_phy_mode(struct platform_device *pdev)
+{
+	const char *pm;
+	int err, i;
+	int phy_interface;
+
+	err = device_property_read_string(&pdev->dev, "phy-mode", &pm);
+	if (err < 0)
+		return err;
+
+	phy_interface = PHYTMAC_PHY_INTERFACE_MODE_MAX + 1;
+	for (i = 0; i < PHYTMAC_PHY_INTERFACE_MODE_MAX; i++) {
+		if (!strcasecmp(pm, phytmac_phy_modes(i))) {
+			phy_interface = i;
+			dev_notice(&pdev->dev, "Phy mode is %s.\n", pm);
+			break;
+		}
+	}
+
+	if (phy_interface > PHYTMAC_PHY_INTERFACE_MODE_MAX) {
+		dev_err(&pdev->dev, "Invalid phy mode value: %s!\n", pm);
+		return -EINVAL;
+	}
+
+	return phy_interface;
+}
+
 static int phytmac_get_phy_mode(struct platform_device *pdev)
 {
 	const char *pm;
@@ -80,6 +172,8 @@ static int phytmac_plat_probe(struct platform_device *pdev)
 	struct phytmac *pdata;
 	int ret, i;
 	u32 queue_num;
+	const struct of_device_id *match = NULL;
+	const struct acpi_device_id *match_acpi = NULL;

 	pdata = phytmac_alloc_pdata(&pdev->dev);
 	if (IS_ERR(pdata)) {
@@ -92,8 +186,6 @@ static int phytmac_plat_probe(struct platform_device *pdev)
 	pdata->platdev = pdev;

 	if (pdev->dev.of_node) {
-		const struct of_device_id *match;
-
 		match = of_match_node(phytmac_dt_ids, np);
 		if (match && match->data) {
 			phytmac_config = match->data;
@@ -102,11 +194,9 @@ static int phytmac_plat_probe(struct platform_device *pdev)
 			pdata->queues_max_num = phytmac_config->queue_num;
 		}
 	} else if (has_acpi_companion(&pdev->dev)) {
-		const struct acpi_device_id *match;
-
-		match = acpi_match_device(phytmac_acpi_ids, &pdev->dev);
-		if (match && match->driver_data) {
-			phytmac_config = (void *)match->driver_data;
+		match_acpi = acpi_match_device(phytmac_acpi_ids, &pdev->dev);
+		if (match_acpi && match_acpi->driver_data) {
+			phytmac_config = (void *)match_acpi->driver_data;
 			pdata->hw_if = phytmac_config->hw_if;
 			pdata->capacities = phytmac_config->caps;
 			pdata->queues_max_num = phytmac_config->queue_num;
@@ -122,6 +212,18 @@ static int phytmac_plat_probe(struct platform_device *pdev)
 	}
 	pdata->ndev->base_addr = regs->start;

+	if (pdev->dev.of_node && match) {
+		if (!strcmp(match->compatible, "phytium,gmac-1.0"))
+			pdata->version = PHYTMAC_READ(pdata, PHYTMAC_VERSION) & 0xff;
+		else
+			pdata->version = VERSION_V3;
+	} else if (has_acpi_companion(&pdev->dev) && match_acpi) {
+		if (!strcmp(match_acpi->id, "PHYT0046"))
+			pdata->version = PHYTMAC_READ(pdata, PHYTMAC_VERSION) & 0xff;
+		else
+			pdata->version = VERSION_V3;
+	}
+
 	if (pdata->capacities & PHYTMAC_CAPS_MSG) {
 		++i;
 		regs = platform_get_resource(pdev, IORESOURCE_MEM, i);
@@ -134,11 +236,10 @@ static int phytmac_plat_probe(struct platform_device *pdev)
 		}
 	}

-	if (device_property_read_bool(&pdev->dev, "lpi"))
-		pdata->capacities |= PHYTMAC_CAPS_LPI;
+	if (device_property_read_bool(&pdev->dev, "powerctrl"))
+		pdata->capacities |= PHYTMAC_CAPS_PWCTRL;

-	if (pdata->capacities & PHYTMAC_CAPS_LPI) {
-		/* lpi resource */
+	if (pdata->version == VERSION_V3 && pdev->dev.of_node) {
 		++i;
 		regs = platform_get_resource(pdev, IORESOURCE_MEM, i);
 		if (regs) {
@@ -181,6 +282,14 @@ static int phytmac_plat_probe(struct platform_device *pdev)
 	else
 		pdata->phy_interface = ret;

+	if (pdata->version == VERSION_V3) {
+		ret = phytmac_v2_get_phy_mode(pdev);
+		if (ret < 0)
+			pdata->phytmac_v2_interface = PHYTMAC_PHY_INTERFACE_MODE_USXGMII;
+		else
+			pdata->phytmac_v2_interface = ret;
+	}
+
 	ret = phytmac_drv_probe(pdata);
 	if (ret)
 		goto err_mem;
@@ -212,6 +321,13 @@ static int phytmac_plat_remove(struct platform_device *pdev)
 	return 0;
 }

+static void phytmac_plat_shutdown(struct platform_device *pdev)
+{
+	struct phytmac *pdata = platform_get_drvdata(pdev);
+
+	phytmac_drv_shutdown(pdata);
+}
+
 static int __maybe_unused phytmac_plat_suspend(struct device *dev)
 {
 	struct phytmac *pdata = dev_get_drvdata(dev);
@@ -245,6 +361,7 @@ static struct platform_driver phytmac_driver = {
 		.acpi_match_table = phytmac_acpi_ids,
 		.pm = &phytmac_plat_pm_ops,
 	},
+	.shutdown = phytmac_plat_shutdown,
 };

 module_platform_driver(phytmac_driver);
diff --git a/drivers/net/ethernet/phytium/phytmac_ptp.c b/drivers/net/ethernet/phytium/phytmac_ptp.c
index 26b1b75edbde..4803842bd7c1 100644
--- a/drivers/net/ethernet/phytium/phytmac_ptp.c
+++ b/drivers/net/ethernet/phytium/phytmac_ptp.c
@@ -2,6 +2,9 @@
 /**
  * 1588 PTP support for Phytium GMAC device.
  *
+ * Copyright(c) 2022 - 2025 Phytium Technology Co., Ltd.
+ *
+ * Author: Wenting Song <songwenting@phytium.com>
  */
 #include <linux/kernel.h>
 #include <linux/types.h>
diff --git a/drivers/net/ethernet/phytium/phytmac_ptp.h b/drivers/net/ethernet/phytium/phytmac_ptp.h
index 72c8b7c67413..e9497a172d25 100644
--- a/drivers/net/ethernet/phytium/phytmac_ptp.h
+++ b/drivers/net/ethernet/phytium/phytmac_ptp.h
@@ -2,6 +2,7 @@
 /*
  * Phytium Ethernet Controller driver
  *
+ * Copyright(c) 2022 - 2025 Phytium Technology Co., Ltd.
  *
  * This program is free software; you can redistribute it and/or modify
  * it under the terms of the GNU General Public License version 2 as
diff --git a/drivers/net/ethernet/phytium/phytmac_v1.c b/drivers/net/ethernet/phytium/phytmac_v1.c
index 72a6eeaec356..4fc0bfa2f696 100644
--- a/drivers/net/ethernet/phytium/phytmac_v1.c
+++ b/drivers/net/ethernet/phytium/phytmac_v1.c
@@ -1,4 +1,5 @@
 // SPDX-License-Identifier: GPL-2.0-only
+/* Copyright(c) 2022 - 2025 Phytium Technology Co., Ltd. */

 #include <linux/kernel.h>
 #include <linux/types.h>
@@ -14,6 +15,7 @@
 #include <linux/circ_buf.h>
 #include <linux/spinlock.h>
 #include <linux/ptp_clock_kernel.h>
+#include <linux/acpi.h>
 #include "phytmac.h"
 #include "phytmac_v1.h"

@@ -211,6 +213,11 @@ static int phytmac_mac_linkup(struct phytmac *pdata, phy_interface_t interface,
 	else
 		PHYTMAC_WRITE(pdata, PHYTMAC_HCONFIG, PHYTMAC_SPEED_100M);

+	if (interface == PHY_INTERFACE_MODE_SGMII) {
+		if (speed == SPEED_2500)
+			phytmac_enable_autoneg(pdata, 0);
+	}
+
 	return 0;
 }

@@ -289,7 +296,6 @@ static int phytmac_set_mac_addr(struct phytmac *pdata, const u8 *addr)

 static void phytmac_reset_hw(struct phytmac *pdata)
 {
-	struct phytmac_queue *queue;
 	unsigned int q;
 	u32 ctrl;

@@ -300,7 +306,7 @@ static void phytmac_reset_hw(struct phytmac *pdata)
 	PHYTMAC_WRITE(pdata, PHYTMAC_NCTRL, ctrl);

 	/* Disable and clear all interrupts and disable queues */
-	for (q = 0, queue = pdata->queues; q < pdata->queues_max_num; ++q, ++queue) {
+	for (q = 0; q < pdata->queues_max_num; ++q) {
 		if (q == 0) {
 			PHYTMAC_WRITE(pdata, PHYTMAC_ID, -1);
 			PHYTMAC_WRITE(pdata, PHYTMAC_IS, -1);
@@ -317,7 +323,10 @@ static void phytmac_reset_hw(struct phytmac *pdata)
 		PHYTMAC_WRITE(pdata, PHYTMAC_RXPTRH(q), 0);

 		if (pdata->capacities & PHYTMAC_CAPS_TAILPTR)
-			PHYTMAC_WRITE(pdata, PHYTMAC_TAILPTR(q), 0);
+			PHYTMAC_WRITE(pdata, PHYTMAC_TX_TAILPTR(q), 0);
+
+		if (pdata->capacities & PHYTMAC_CAPS_RXPTR)
+			PHYTMAC_WRITE(pdata, PHYTMAC_RX_TAILPTR(q), 0);
 	}
 }

@@ -352,6 +361,7 @@ static int phytmac_init_hw(struct phytmac *pdata)
 	u32 config = PHYTMAC_READ(pdata, PHYTMAC_NCONFIG);
 	u32 dmaconfig;
 	u32 nctrlconfig;
+	u32 ptrconfig = 0;

 	nctrlconfig = PHYTMAC_READ(pdata, PHYTMAC_NCTRL);
 	nctrlconfig |= PHYTMAC_BIT(MPE);
@@ -414,7 +424,14 @@ static int phytmac_init_hw(struct phytmac *pdata)
 	PHYTMAC_WRITE(pdata, PHYTMAC_DCONFIG, dmaconfig);

 	if (pdata->capacities & PHYTMAC_CAPS_TAILPTR)
-		PHYTMAC_WRITE(pdata, PHYTMAC_TAIL_ENABLE, PHYTMAC_BIT(TXTAIL_ENABLE));
+		ptrconfig |= PHYTMAC_BIT(TXPTR_EN);
+	if (pdata->capacities & PHYTMAC_CAPS_RXPTR)
+		ptrconfig |= PHYTMAC_BIT(RXPTR_EN);
+
+	PHYTMAC_WRITE(pdata, PHYTMAC_TAIL_ENABLE, ptrconfig);
+
+	if (pdata->capacities & PHYTMAC_CAPS_START)
+		PHYTMAC_WRITE(pdata, PHYTMAC_TXSTARTSEL, PHYTMAC_BIT(TSTARTSEL_ENABLE));

 	if (phy_interface_mode_is_8023z(pdata->phy_interface))
 		phytmac_pcs_software_reset(pdata, 1);
@@ -426,8 +443,46 @@ static int phytmac_powerup_hw(struct phytmac *pdata, int on)
 {
 	u32 status, data0, data1, rdata1;
 	int ret;
+	acpi_handle handle;
+	union acpi_object args[3];
+	struct acpi_object_list arg_list = {
+		.pointer = args,
+		.count = ARRAY_SIZE(args),
+	};
+	acpi_status acpi_sts;
+	unsigned long long rv;
+
+	if (!(pdata->capacities & PHYTMAC_CAPS_PWCTRL)) {
+		pdata->power_state = on;
+		return 0;
+	}
+
+	if (has_acpi_companion(pdata->dev)) {
+		handle = ACPI_HANDLE(pdata->dev);

-	if (pdata->capacities & PHYTMAC_CAPS_LPI) {
+		netdev_info(pdata->ndev, "set gmac power %s\n",
+			    on == PHYTMAC_POWERON ? "on" : "off");
+		args[0].type = ACPI_TYPE_INTEGER;
+		args[0].integer.value = PHYTMAC_PWCTL_GMAC_ID;
+		args[1].type = ACPI_TYPE_INTEGER;
+		args[1].integer.value = PHYTMAC_PWCTL_DEFAULT_VAL;
+		args[2].type = ACPI_TYPE_INTEGER;
+		args[2].integer.value = PHYTMAC_PWCTL_DEFAULT_VAL;
+
+		if (on == PHYTMAC_POWERON) {
+			acpi_sts = acpi_evaluate_integer(handle, "PPWO", &arg_list, &rv);
+			if (ACPI_FAILURE(acpi_sts))
+				netdev_err(pdata->ndev, "NO PPWO Method\n");
+			if (rv)
+				netdev_err(pdata->ndev, "Failed to power on\n");
+		} else {
+			acpi_sts = acpi_evaluate_integer(handle, "PPWD", &arg_list, &rv);
+			if (ACPI_FAILURE(acpi_sts))
+				netdev_err(pdata->ndev, "NO PPWD Method\n");
+			if (rv)
+				netdev_err(pdata->ndev, "Failed to power off\n");
+		}
+	} else {
 		ret = readx_poll_timeout(PHYTMAC_READ_STAT, pdata, status, !status,
 					 1, PHYTMAC_TIMEOUT);
 		if (ret)
@@ -460,16 +515,17 @@ static int phytmac_powerup_hw(struct phytmac *pdata, int on)
 					 data0 & PHYTMAC_BIT(DATA0_FREE),
 					 1, PHYTMAC_TIMEOUT);
 		if (ret)
-			netdev_err(pdata->ndev, "mnh data0 is busy");
+			netdev_err(pdata->ndev, "mnh data0 is busy\n");

 		rdata1 = PHYTMAC_MHU_READ(pdata, PHYTMAC_MHU_CPP_DATA1);
 		if (rdata1 == data1)
 			netdev_err(pdata->ndev, "gmac power %s success, data1 = %x, rdata1=%x\n",
-				   on ? "up" : "down", data1, rdata1);
+				   on == PHYTMAC_POWERON ? "up" : "down", data1, rdata1);
 		else
 			netdev_err(pdata->ndev, "gmac power %s failed, data1 = %x, rdata1=%x\n",
-				   on ? "up" : "down", data1, rdata1);
+				   on == PHYTMAC_POWERON ? "up" : "down", data1, rdata1);
 	}
+
 	pdata->power_state = on;

 	return 0;
@@ -626,6 +682,9 @@ static int phytmac_get_feature_all(struct phytmac *pdata)
 	/* max rx fs */
 	pdata->max_rx_fs = PHYTMAC_READ_BITS(pdata, PHYTMAC_DEFAULT3, SCR2CMP);

+	if (pdata->version == VERSION_V3)
+		pdata->capacities |= PHYTMAC_CAPS_RXPTR;
+
 	if (netif_msg_hw(pdata))
 		netdev_info(pdata->ndev, "get feature queue_num=%d, daw=%d, dbw=%d, rx_fs=%d, rx_bd=%d, tx_bd=%d\n",
 			    pdata->queues_num, pdata->dma_addr_width, pdata->dma_data_width,
@@ -756,7 +815,7 @@ static int phytmac_init_ring_hw(struct phytmac *pdata)
 		PHYTMAC_WRITE(pdata, PHYTMAC_RXPTRH(q), upper_32_bits(queue->rx_ring_addr));

 		if (pdata->capacities & PHYTMAC_CAPS_TAILPTR)
-			PHYTMAC_WRITE(pdata, PHYTMAC_TAILPTR(q), queue->tx_tail);
+			PHYTMAC_WRITE(pdata, PHYTMAC_TX_TAILPTR(q), queue->tx_tail);
 	}

 	return 0;
@@ -928,7 +987,8 @@ static unsigned int phytmac_rx_map_desc(struct phytmac_queue *queue,
 		desc->desc1 = 0;
 		desc->desc2 = upper_32_bits(addr);
 		/* Make newly descriptor to hardware */
-		dma_wmb();
+		if (!(pdata->capacities & PHYTMAC_CAPS_RXPTR))
+			dma_wmb();
 		desc->desc0 = lower_32_bits(addr);
 	} else {
 		desc->desc1 = 0;
@@ -948,32 +1008,33 @@ static unsigned int phytmac_zero_rx_desc_addr(struct phytmac_dma_desc *desc)
 	return 0;
 }

+static unsigned int phytmac_zero_tx_desc(struct phytmac_dma_desc *desc)
+{
+	desc->desc2 = 0;
+	desc->desc0 = 0;
+	desc->desc1 &= ~PHYTMAC_BIT(TX_USED);
+
+	return 0;
+}
+
 static void phytmac_tx_start(struct phytmac_queue *queue)
 {
 	struct phytmac *pdata = queue->pdata;

 	if (pdata->capacities & PHYTMAC_CAPS_TAILPTR)
-		PHYTMAC_WRITE(pdata, PHYTMAC_TAILPTR(queue->index),
+		PHYTMAC_WRITE(pdata, PHYTMAC_TX_TAILPTR(queue->index),
 			      PHYTMAC_BIT(TXTAIL_UPDATE) | queue->tx_tail);

-	if (pdata->capacities & PHYTMAC_CAPS_START)
-		PHYTMAC_WRITE(pdata, PHYTMAC_NCTRL,
-			      PHYTMAC_READ(pdata, PHYTMAC_NCTRL) | PHYTMAC_BIT(TSTART));
+	if (likely(pdata->capacities & PHYTMAC_CAPS_START))
+		PHYTMAC_WRITE(pdata, PHYTMAC_TXSTART, PHYTMAC_BIT(TSTART));
 }

-static void phytmac_restart(struct phytmac *pdata)
+static void phytmac_update_rx_tail(struct phytmac_queue *queue)
 {
-	int q;
-	struct phytmac_queue *queue;
+	struct phytmac *pdata = queue->pdata;

-	for (q = 0; q < pdata->queues_num; q++) {
-		queue = &pdata->queues[q];
-		if (queue->tx_head != queue->tx_tail) {
-			PHYTMAC_WRITE(pdata, PHYTMAC_NCTRL,
-				      PHYTMAC_READ(pdata, PHYTMAC_NCTRL) | PHYTMAC_BIT(TSTART));
-			break;
-		}
-	}
+	if (pdata->capacities & PHYTMAC_CAPS_RXPTR)
+		PHYTMAC_WRITE(pdata, PHYTMAC_RX_TAILPTR(queue->index), queue->rx_head);
 }

 static int phytmac_tx_complete(const struct phytmac_dma_desc *desc)
@@ -1116,7 +1177,7 @@ static void phytmac_mac_interface_config(struct phytmac *pdata, unsigned int mod

 	/* Disable AN for SGMII fixed link or speed equal to 2.5G, enable otherwise.*/
 	if (state->interface == PHY_INTERFACE_MODE_SGMII) {
-		if (state->speed == SPEED_2500 || mode == MLO_AN_FIXED)
+		if (mode == MLO_AN_FIXED)
 			phytmac_enable_autoneg(pdata, 0);
 		else
 			phytmac_enable_autoneg(pdata, 1);
@@ -1158,7 +1219,7 @@ static void phytmac_clear_tx_desc(struct phytmac_queue *queue)
 	desc->desc1 |= PHYTMAC_BIT(TX_WRAP);

 	if (pdata->capacities & PHYTMAC_CAPS_TAILPTR)
-		PHYTMAC_WRITE(pdata, PHYTMAC_TAILPTR(queue->index), queue->tx_tail);
+		PHYTMAC_WRITE(pdata, PHYTMAC_TX_TAILPTR(queue->index), queue->tx_tail);
 }

 static void phytmac_get_hw_stats(struct phytmac *pdata)
@@ -1388,7 +1449,7 @@ struct phytmac_hw_if phytmac_1p0_hw = {
 	/* tx and rx */
 	.tx_map = phytmac_tx_map_desc,
 	.transmit = phytmac_tx_start,
-	.restart = phytmac_restart,
+	.update_rx_tail = phytmac_update_rx_tail,
 	.tx_complete = phytmac_tx_complete,
 	.rx_complete = phytmac_rx_complete,
 	.get_rx_pkt_len = phytmac_rx_pkt_len,
@@ -1401,6 +1462,7 @@ struct phytmac_hw_if phytmac_1p0_hw = {
 	.clear_rx_desc = phytmac_clear_rx_desc,
 	.clear_tx_desc = phytmac_clear_tx_desc,
 	.zero_rx_desc_addr = phytmac_zero_rx_desc_addr,
+	.zero_tx_desc = phytmac_zero_tx_desc,
 	/* ptp */
 	.init_ts_hw = phytmac_ptp_init_hw,
 	.set_time = phytmac_set_time,
diff --git a/drivers/net/ethernet/phytium/phytmac_v1.h b/drivers/net/ethernet/phytium/phytmac_v1.h
index 32bb12949109..e0ca0ab83547 100644
--- a/drivers/net/ethernet/phytium/phytmac_v1.h
+++ b/drivers/net/ethernet/phytium/phytmac_v1.h
@@ -1,4 +1,6 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
+/* Copyright(c) 2022 - 2025 Phytium Technology Co., Ltd. */
+
 #ifndef _PHYTMAC_V1_H
 #define _PHYTMAC_V1_H

@@ -53,6 +55,9 @@ extern struct phytmac_hw_if phytmac_1p0_hw;
 #define PHYTMAC_USXSTATUS		0x0A88
 #define PHYTMAC_TXBDCTRL		0x04CC
 #define PHYTMAC_RXBDCTRL		0x04D0
+#define PHYTMAC_TXSTART			0x0E70
+#define PHYTMAC_TXSTARTSEL		0x0E74
+#define PHYTMAC_VERSION			0x0FF0

 /* Fdir match registers */
 #define PHYTMAC_FDIR(i)			(0x0540 + ((i) << 2))
@@ -75,7 +80,8 @@ extern struct phytmac_hw_if phytmac_1p0_hw;
 #define PHYTMAC_IDR(i)			(0x0620 + ((i) << 2))
 #define PHYTMAC_IMR(i)			(0x0640 + ((i) << 2))
 #define PHYTMAC_TAIL_ENABLE		(0x0e7c)
-#define PHYTMAC_TAILPTR(i)		(0x0e80 + ((i) << 2))
+#define PHYTMAC_TX_TAILPTR(i)	(0x0e80 + ((i) << 2))
+#define PHYTMAC_RX_TAILPTR(i)	(0x0ec0 + ((i) << 2))

 #define PHYTMAC_PHY_INT_ENABLE		0x1C88
 #define PHYTMAC_PHY_INT_CLEAR		0x1C8C
@@ -363,8 +369,11 @@ extern struct phytmac_hw_if phytmac_1p0_hw;
 #define PHYTMAC_TXTAIL_UPDATE_WIDTH		1

 /* Bitfields in TAIL_ENABLE */
-#define PHYTMAC_TXTAIL_ENABLE_INDEX		0 /* Enable tx tail */
-#define PHYTMAC_TXTAIL_ENABLE_WIDTH		1
+#define PHYTMAC_TXPTR_EN_INDEX		0	/* Enable tx tail */
+#define PHYTMAC_TXPTR_EN_WIDTH		1
+
+#define PHYTMAC_RXPTR_EN_INDEX		16	/* Enable rx tail */
+#define PHYTMAC_RXPTR_EN_WIDTH		1

 /* Bitfields in INT ENABLE */
 #define PHYTMAC_WOL_RECEIVE_ENABLE_INDEX    28 /* Enable wol_event_recieve */
@@ -374,6 +383,10 @@ extern struct phytmac_hw_if phytmac_1p0_hw;
 #define PHYTMAC_WOL_RECEIVE_DISABLE_INDEX    28 /* Disable wol_event_recieve */
 #define PHYTMAC_WOL_RECEIVE_DISABLE_WIDTH    1

+/* Bitfields in PHYTMAC_TXSTARTSEL */
+#define PHYTMAC_TSTARTSEL_ENABLE_INDEX 0 /* Enable Tstart_sel */
+#define PHYTMAC_TSTARTSEL_ENABLE_WIDTH 1
+
 #define PHYTMAC_TSEC_WIDTH (PHYTMAC_SECH_WIDTH + PHYTMAC_SECL_WIDTH)
 #define SEC_MAX_VAL (((u64)1 << PHYTMAC_TSEC_WIDTH) - 1)
 #define NSEC_MAX_VAL ((1 << PHYTMAC_NSEC_WIDTH) - 1)
diff --git a/drivers/net/ethernet/phytium/phytmac_v2.c b/drivers/net/ethernet/phytium/phytmac_v2.c
index 25f1ba6c1d6e..b8af75b3d934 100644
--- a/drivers/net/ethernet/phytium/phytmac_v2.c
+++ b/drivers/net/ethernet/phytium/phytmac_v2.c
@@ -1,4 +1,6 @@
 // SPDX-License-Identifier: GPL-2.0-only
+/* Copyright(c) 2022 - 2025 Phytium Technology Co., Ltd. */
+
 #include <linux/kernel.h>
 #include <linux/types.h>
 #include <linux/clk.h>
@@ -13,17 +15,19 @@
 #include <linux/circ_buf.h>
 #include <linux/spinlock.h>
 #include <linux/ptp_clock_kernel.h>
+#include <linux/acpi.h>
 #include "phytmac.h"
 #include "phytmac_v2.h"

-static int phytmac_msg_send(struct phytmac *pdata, u16 cmd_id,
-			    u16 cmd_subid, void *data, int len, int wait)
+static int phytmac_v2_msg_send(struct phytmac *pdata, u16 cmd_id,
+			       u16 cmd_subid, void *data, int len, int wait)
 {
 	int index = 0;
 	struct phytmac_msg_info msg;
 	struct phytmac_msg_info msg_rx;
 	int ret = 0;

+	mutex_lock(&pdata->msg_ring.msg_mutex);
 	++pdata->msg_ring.tx_msg_tail;
 	if (pdata->msg_ring.tx_msg_tail > pdata->msg_ring.tx_msg_ring_size)
 		pdata->msg_ring.tx_msg_tail = 1;
@@ -32,17 +36,17 @@ static int phytmac_msg_send(struct phytmac *pdata, u16 cmd_id,
 	wait = 1;
 	memset(&msg, 0, sizeof(msg));
 	memset(&msg_rx, 0, sizeof(msg_rx));
-	msg.module_id = PHYTMAC_MODULE_ID_GMAC;
-	msg.cmd_id = cmd_id;
+	msg.cmd_type = cmd_id;
 	msg.cmd_subid = cmd_subid;
-	msg.flags = PHYTMAC_FLAGS_MSG_NOINT;
+	msg.status0 = PHYTMAC_FLAGS_MSG_NOINT;

 	if (len)
 		memcpy(&msg.para[0], data, len);

 	if (netif_msg_hw(pdata)) {
-		netdev_info(pdata->ndev, "tx msg: cmdid=%d, subid=%d, flags=%d, len=%d, tail=%d\n",
-			    msg.cmd_id, msg.cmd_subid, msg.flags, len, pdata->msg_ring.tx_msg_tail);
+		netdev_info(pdata->ndev, "tx msg: cmdid:%d, subid:%d, status0:%d, len:%d, tail:%d\n",
+			    msg.cmd_type, msg.cmd_subid, msg.status0, len,
+			    pdata->msg_ring.tx_msg_tail);
 	}

 	memcpy(pdata->msg_regs + PHYTMAC_MSG(index), &msg, sizeof(msg));
@@ -51,16 +55,17 @@ static int phytmac_msg_send(struct phytmac *pdata, u16 cmd_id,

 	if (wait) {
 		memcpy(&msg_rx, pdata->msg_regs + PHYTMAC_MSG(index), MSG_HDR_LEN);
-		while (!(msg_rx.flags & 0x1)) {
+		while (!(msg_rx.status0 & PHYTMAC_CMD_PRC_COMPLETED)) {
 			cpu_relax();
 			memcpy(&msg_rx, pdata->msg_regs + PHYTMAC_MSG(index), MSG_HDR_LEN);
 		}
 	}

+	mutex_unlock(&pdata->msg_ring.msg_mutex);
 	return ret;
 }

-void phytmac_reset_hw(struct phytmac *pdata)
+static void phytmac_v2_reset_hw(struct phytmac *pdata)
 {
 	int q;
 	u16 cmd_id, cmd_subid;
@@ -70,26 +75,27 @@ void phytmac_reset_hw(struct phytmac *pdata)
 	for (q = 0; q < pdata->queues_max_num; ++q) {
 		PHYTMAC_WRITE(pdata, PHYTMAC_INT_DR(q), -1);
 		PHYTMAC_WRITE(pdata, PHYTMAC_INT_SR(q), -1);
-		PHYTMAC_WRITE(pdata, PHYTMAC_TAIL_PTR(q), 0);
+		PHYTMAC_WRITE(pdata, PHYTMAC_TX_PTR(q), 0);
+		PHYTMAC_WRITE(pdata, PHYTMAC_RX_PTR(q), 0);
 	}

 	/* reset hw rx/tx enable */
 	cmd_id = PHYTMAC_MSG_CMD_DEFAULT;
 	cmd_subid = PHYTMAC_MSG_CMD_DEFAULT_RESET_HW;
-	phytmac_msg_send(pdata, cmd_id, cmd_subid, NULL, 0, 0);
+	phytmac_v2_msg_send(pdata, cmd_id, cmd_subid, NULL, 0, 0);

 	/* reset tx ring */
 	memset(&ring, 0, sizeof(ring));
 	ring.queue_num = pdata->queues_max_num;
 	cmd_subid = PHYTMAC_MSG_CMD_DEFAULT_RESET_TX_QUEUE;
-	phytmac_msg_send(pdata, cmd_id, cmd_subid, (void *)(&ring), sizeof(ring), 0);
+	phytmac_v2_msg_send(pdata, cmd_id, cmd_subid, (void *)(&ring), sizeof(ring), 0);

 	/* reset rx ring */
 	cmd_subid = PHYTMAC_MSG_CMD_DEFAULT_RESET_RX_QUEUE;
-	phytmac_msg_send(pdata, cmd_id, cmd_subid, (void *)(&ring), sizeof(ring), 1);
+	phytmac_v2_msg_send(pdata, cmd_id, cmd_subid, (void *)(&ring), sizeof(ring), 1);
 }

-static int phytmac_get_mac_addr(struct phytmac *pdata, u8 *addr)
+static int phytmac_v2_get_mac_addr(struct phytmac *pdata, u8 *addr)
 {
 	int index;
 	u16 cmd_id, cmd_subid;
@@ -97,7 +103,7 @@ static int phytmac_get_mac_addr(struct phytmac *pdata, u8 *addr)

 	cmd_id = PHYTMAC_MSG_CMD_GET;
 	cmd_subid = PHYTMAC_MSG_CMD_GET_ADDR;
-	phytmac_msg_send(pdata, cmd_id, cmd_subid, NULL, 0, 1);
+	phytmac_v2_msg_send(pdata, cmd_id, cmd_subid, NULL, 0, 1);

 	index = pdata->msg_ring.tx_msg_tail;
 	if (index <= 0)
@@ -115,7 +121,7 @@ static int phytmac_get_mac_addr(struct phytmac *pdata, u8 *addr)
 	return 0;
 }

-int phytmac_set_mac_addr(struct phytmac *pdata, const u8 *addr)
+static int phytmac_v2_set_mac_addr(struct phytmac *pdata, const u8 *addr)
 {
 	u16 cmd_id;
 	u16 cmd_subid;
@@ -127,46 +133,70 @@ int phytmac_set_mac_addr(struct phytmac *pdata, const u8 *addr)
 	para.addrl = cpu_to_le32(*((u32 *)addr));
 	para.addrh = cpu_to_le16(*((u16 *)(addr + 4)));

-	phytmac_msg_send(pdata, cmd_id, cmd_subid, (void *)(&para), sizeof(para), 1);
+	phytmac_v2_msg_send(pdata, cmd_id, cmd_subid, (void *)(&para), sizeof(para), 1);
+
+	return 0;
+}
+
+static int phytmac_v2_pcs_software_reset(struct phytmac *pdata, int reset)
+{
+	u16 cmd_id;
+	u16 cmd_subid;
+
+	cmd_id = PHYTMAC_MSG_CMD_SET;
+	if (reset)
+		cmd_subid = PHYTMAC_MSG_CMD_SET_ENABLE_PCS_RESET;
+	else
+		cmd_subid = PHYTMAC_MSG_CMD_SET_DISABLE_PCS_RESET;
+
+	phytmac_v2_msg_send(pdata, cmd_id, cmd_subid, NULL, 0, 0);

 	return 0;
 }

-static int phytmac_init_hw(struct phytmac *pdata)
+static int phytmac_v2_init_hw(struct phytmac *pdata)
 {
 	u16 cmd_id, cmd_subid;
 	struct phytmac_dma_info dma;
 	struct phytmac_eth_info eth;
+	u8 mdc;
+
+	if (pdata->mii_bus) {
+		cmd_id = PHYTMAC_MSG_CMD_SET;
+		cmd_subid = PHYTMAC_MSG_CMD_SET_ENABLE_MDIO;
+		phytmac_v2_msg_send(pdata, cmd_id, cmd_subid, NULL, 0, 0);
+	}

-	phytmac_set_mac_addr(pdata, pdata->ndev->dev_addr);
+	phytmac_v2_set_mac_addr(pdata, pdata->ndev->dev_addr);

 	cmd_id = PHYTMAC_MSG_CMD_SET;
 	if (pdata->capacities & PHYTMAC_CAPS_JUMBO)
 		cmd_subid = PHYTMAC_MSG_CMD_SET_ENABLE_JUMBO;
 	else
 		cmd_subid = PHYTMAC_MSG_CMD_SET_ENABLE_1536_FRAMES;
-	phytmac_msg_send(pdata, cmd_id, cmd_subid, NULL, 0, 0);
+	phytmac_v2_msg_send(pdata, cmd_id, cmd_subid, NULL, 0, 0);

 	if (pdata->ndev->flags & IFF_PROMISC) {
 		cmd_subid = PHYTMAC_MSG_CMD_SET_ENABLE_PROMISE;
-		phytmac_msg_send(pdata, cmd_id, cmd_subid, NULL, 0, 0);
+		phytmac_v2_msg_send(pdata, cmd_id, cmd_subid, NULL, 0, 0);
 	}

 	if (pdata->ndev->features & NETIF_F_RXCSUM) {
 		cmd_subid = PHYTMAC_MSG_CMD_SET_ENABLE_RXCSUM;
-		phytmac_msg_send(pdata, cmd_id, cmd_subid, NULL, 0, 0);
+		phytmac_v2_msg_send(pdata, cmd_id, cmd_subid, NULL, 0, 0);
 	}

-	if (!(pdata->ndev->flags & IFF_BROADCAST)) {
+	if (pdata->ndev->flags & IFF_BROADCAST)
+		cmd_subid = PHYTMAC_MSG_CMD_SET_ENABLE_BC;
+	else
 		cmd_subid = PHYTMAC_MSG_CMD_SET_DISABLE_BC;
-		phytmac_msg_send(pdata, cmd_id, cmd_subid, NULL, 0, 0);
-	}
+	phytmac_v2_msg_send(pdata, cmd_id, cmd_subid, NULL, 0, 0);

 	cmd_subid = PHYTMAC_MSG_CMD_SET_ENABLE_PAUSE;
-	phytmac_msg_send(pdata, cmd_id, cmd_subid, NULL, 0, 0);
+	phytmac_v2_msg_send(pdata, cmd_id, cmd_subid, NULL, 0, 0);

 	cmd_subid = PHYTMAC_MSG_CMD_SET_ENABLE_STRIPCRC;
-	phytmac_msg_send(pdata, cmd_id, cmd_subid, NULL, 0, 0);
+	phytmac_v2_msg_send(pdata, cmd_id, cmd_subid, NULL, 0, 0);

 	memset(&dma, 0, sizeof(dma));
 	cmd_subid = PHYTMAC_MSG_CMD_SET_DMA;
@@ -177,22 +207,31 @@ static int phytmac_init_hw(struct phytmac *pdata)
 		dma.hw_dma_cap |= HW_DMA_CAP_CSUM;
 	if (IS_REACHABLE(CONFIG_PHYTMAC_ENABLE_PTP))
 		dma.hw_dma_cap |= HW_DMA_CAP_PTP;
+	if (pdata->dma_data_width == PHYTMAC_DBW32)
+		dma.hw_dma_cap |= HW_DMA_CAP_DDW32;
 	if (pdata->dma_data_width == PHYTMAC_DBW64)
 		dma.hw_dma_cap |= HW_DMA_CAP_DDW64;
 	if (pdata->dma_data_width == PHYTMAC_DBW128)
 		dma.hw_dma_cap |= HW_DMA_CAP_DDW128;
-	phytmac_msg_send(pdata, cmd_id, cmd_subid, (void *)&dma, sizeof(dma), 0);
+	phytmac_v2_msg_send(pdata, cmd_id, cmd_subid, (void *)&dma, sizeof(dma), 0);
+
+	cmd_subid = PHYTMAC_MSG_CMD_SET_MDC;
+	mdc = PHYTMAC_CLK_DIV96;
+	phytmac_v2_msg_send(pdata, cmd_id, cmd_subid, (void *)(&mdc), sizeof(mdc), 1);

 	memset(&eth, 0, sizeof(eth));
 	cmd_subid = PHYTMAC_MSG_CMD_SET_ETH_MATCH;
 	eth.index = 0;
 	eth.etype = (uint16_t)ETH_P_IP;
-	phytmac_msg_send(pdata, cmd_id, cmd_subid, (void *)&eth, sizeof(eth), 1);
+	phytmac_v2_msg_send(pdata, cmd_id, cmd_subid, (void *)&eth, sizeof(eth), 1);
+
+	if (phy_interface_mode_is_8023z(pdata->phy_interface))
+		phytmac_v2_pcs_software_reset(pdata, 1);

 	return 0;
 }

-static int phytmac_enable_multicast(struct phytmac *pdata, int enable)
+static int phytmac_v2_enable_multicast(struct phytmac *pdata, int enable)
 {
 	u16 cmd_id, cmd_subid;

@@ -202,11 +241,11 @@ static int phytmac_enable_multicast(struct phytmac *pdata, int enable)
 	else
 		cmd_subid = PHYTMAC_MSG_CMD_SET_DISABLE_MC;

-	phytmac_msg_send(pdata, cmd_id, cmd_subid, NULL, 0, 1);
+	phytmac_v2_msg_send(pdata, cmd_id, cmd_subid, NULL, 0, 1);
 	return 0;
 }

-static int phytmac_set_mc_hash(struct phytmac *pdata, unsigned long *mc_filter)
+static int phytmac_v2_set_mc_hash(struct phytmac *pdata, unsigned long *mc_filter)
 {
 	u16 cmd_id, cmd_subid;
 	struct phytmac_mc_info para;
@@ -216,12 +255,12 @@ static int phytmac_set_mc_hash(struct phytmac *pdata, unsigned long *mc_filter)
 	cmd_subid = PHYTMAC_MSG_CMD_SET_ENABLE_HASH_MC;
 	para.mc_bottom = (u32)mc_filter[0];
 	para.mc_top = (u32)mc_filter[1];
-	phytmac_msg_send(pdata, cmd_id, cmd_subid, (void *)(&para), sizeof(para), 1);
+	phytmac_v2_msg_send(pdata, cmd_id, cmd_subid, (void *)(&para), sizeof(para), 1);

 	return 0;
 }

-static int phytmac_init_ring_hw(struct phytmac *pdata)
+static int phytmac_v2_init_ring_hw(struct phytmac *pdata)
 {
 	u16 cmd_id, cmd_subid;
 	struct phytmac_ring_info rxring;
@@ -240,27 +279,27 @@ static int phytmac_init_ring_hw(struct phytmac *pdata)
 	txring.hw_dma_cap |= HW_DMA_CAP_64B;
 	rxring.hw_dma_cap |= HW_DMA_CAP_64B;
 	for (q = 0, queue = pdata->queues; q < pdata->queues_num; ++q, ++queue) {
-		PHYTMAC_WRITE(pdata, PHYTMAC_TAIL_PTR(q), queue->tx_head);
+		PHYTMAC_WRITE(pdata, PHYTMAC_TX_PTR(q), queue->tx_head);
 		txring.addr[q] = queue->tx_ring_addr;
 		rxring.addr[q] = queue->rx_ring_addr;
 	}

-	phytmac_msg_send(pdata, cmd_id, cmd_subid, (void *)(&txring), sizeof(txring), 0);
+	phytmac_v2_msg_send(pdata, cmd_id, cmd_subid, (void *)(&txring), sizeof(txring), 0);

 	cmd_id = PHYTMAC_MSG_CMD_SET;
 	cmd_subid = PHYTMAC_MSG_CMD_SET_DMA_RX_BUFSIZE;
 	rxbuf.queue_num = pdata->queues_num;
 	rxbuf.buffer_size = pdata->rx_buffer_len / 64;
-	phytmac_msg_send(pdata, cmd_id, cmd_subid, (void *)(&rxbuf), sizeof(rxbuf), 0);
+	phytmac_v2_msg_send(pdata, cmd_id, cmd_subid, (void *)(&rxbuf), sizeof(rxbuf), 0);

 	cmd_id = PHYTMAC_MSG_CMD_SET;
 	cmd_subid = PHYTMAC_MSG_CMD_SET_INIT_RX_RING;
-	phytmac_msg_send(pdata, cmd_id, cmd_subid, (void *)(&rxring), sizeof(rxring), 0);
+	phytmac_v2_msg_send(pdata, cmd_id, cmd_subid, (void *)(&rxring), sizeof(rxring), 0);

 	return 0;
 }

-int phytmac_init_msg_ring(struct phytmac *pdata)
+static int phytmac_v2_init_msg_ring(struct phytmac *pdata)
 {
 	u32 size = 0;

@@ -278,7 +317,7 @@ int phytmac_init_msg_ring(struct phytmac *pdata)
 	return 0;
 }

-static int phytmac_get_feature_all(struct phytmac *pdata)
+static int phytmac_v2_get_feature_all(struct phytmac *pdata)
 {
 	u16 cmd_id, cmd_subid;
 	int index;
@@ -287,7 +326,7 @@ static int phytmac_get_feature_all(struct phytmac *pdata)
 	memset(&para, 0, sizeof(para));
 	cmd_id = PHYTMAC_MSG_CMD_GET;
 	cmd_subid = PHYTMAC_MSG_CMD_GET_CAPS;
-	phytmac_msg_send(pdata, cmd_id, cmd_subid, NULL, 0, 1);
+	phytmac_v2_msg_send(pdata, cmd_id, cmd_subid, NULL, 0, 1);

 	index = pdata->msg_ring.tx_msg_tail;
 	if (index <= 0)
@@ -317,25 +356,26 @@ static int phytmac_get_feature_all(struct phytmac *pdata)
 	return 0;
 }

-void phytmac_get_regs(struct phytmac *pdata, u32 *reg_buff)
+static void phytmac_v2_get_regs(struct phytmac *pdata, u32 *reg_buff)
 {
 	u16 cmd_id, cmd_subid;
-	u16 reg_num;
 	int index;
+	u8 interface;

 	cmd_id = PHYTMAC_MSG_CMD_GET;
-	cmd_subid = PHYTMAC_MSG_CMD_GET_REG_READ;
-	reg_num = 16;
-	phytmac_msg_send(pdata, cmd_id, cmd_subid, (void *)&reg_num, 2, 1);
+	cmd_subid = PHYTMAC_MSG_CMD_GET_REGS_FOR_ETHTOOL;
+	interface = pdata->phytmac_v2_interface;
+	phytmac_v2_msg_send(pdata, cmd_id, cmd_subid, (void *)(&interface), sizeof(interface), 1);

 	index = pdata->msg_ring.tx_msg_tail;
 	if (index <= 0)
 		index += pdata->msg_ring.tx_msg_ring_size;

-	memcpy(reg_buff, pdata->msg_regs + PHYTMAC_MSG(index) + MSG_HDR_LEN, 64);
+	memcpy(reg_buff, pdata->msg_regs + PHYTMAC_MSG(index) + MSG_HDR_LEN,
+	       READ_REG_NUM_MAX * sizeof(u32));
 }

-static void phytmac_get_hw_stats(struct phytmac *pdata)
+static void phytmac_v2_get_hw_stats(struct phytmac *pdata)
 {
 	u16 cmd_id, cmd_subid;
 	u8 count;
@@ -346,27 +386,20 @@ static void phytmac_get_hw_stats(struct phytmac *pdata)

 	cmd_id = PHYTMAC_MSG_CMD_GET;
 	cmd_subid = PHYTMAC_MSG_CMD_GET_STATS;
-	count = 1;
-	phytmac_msg_send(pdata, cmd_id, cmd_subid, (void *)&count, sizeof(count), 0);
-
-	cmd_id = PHYTMAC_MSG_CMD_GET;
-	cmd_subid = PHYTMAC_MSG_CMD_GET_STATS;
-	count = 2;
-	phytmac_msg_send(pdata, cmd_id, cmd_subid, (void *)&count, sizeof(count), 0);
+	/* There are 45 registers in total, read 16 regs at a time, read 13 regs at last time */
+	for (i = 1; i <= 3; i++) {
+		count = i;
+		phytmac_v2_msg_send(pdata, cmd_id, cmd_subid, (void *)&count, sizeof(count), 1);

-	cmd_id = PHYTMAC_MSG_CMD_GET;
-	cmd_subid = PHYTMAC_MSG_CMD_GET_STATS;
-	count = 3;
-	phytmac_msg_send(pdata, cmd_id, cmd_subid, (void *)&count, sizeof(count), 1);
-
-	for (i = 0; i < 3; i++) {
-		index = pdata->msg_ring.tx_msg_tail + i - 2;
+		index = pdata->msg_ring.tx_msg_tail;
 		if (index <= 0)
 			index += pdata->msg_ring.tx_msg_ring_size;
-		memcpy(&stats[i * 16], pdata->msg_regs + PHYTMAC_MSG(index) + MSG_HDR_LEN, 64);
+
+		memcpy(&stats[(i - 1) * READ_REG_NUM_MAX], pdata->msg_regs + PHYTMAC_MSG(index) +
+				MSG_HDR_LEN, sizeof(u32) * READ_REG_NUM_MAX);
 	}

-	for (i = 0, j = 0; i < 44; i++) {
+	for (i = 0, j = 0; i < 45; i++) {
 		if (i == 0 || i == 20) {
 			val = (u64)stats[i + 1] << 32 | stats[i];
 			*p += val;
@@ -385,7 +418,7 @@ static void phytmac_get_hw_stats(struct phytmac *pdata)
 	}
 }

-static void phytmac_mdio_idle(struct phytmac *pdata)
+static void phytmac_v2_mdio_idle(struct phytmac *pdata)
 {
 	u32 val;

@@ -397,7 +430,7 @@ static void phytmac_mdio_idle(struct phytmac *pdata)
 	}
 }

-static int phytmac_mdio_data_read_c22(struct phytmac *pdata, int mii_id, int regnum)
+static int phytmac_v2_mdio_data_read_c22(struct phytmac *pdata, int mii_id, int regnum)
 {
 	u16 data;

@@ -406,14 +439,14 @@ static int phytmac_mdio_data_read_c22(struct phytmac *pdata, int mii_id, int reg
 		      | PHYTMAC_BITS(PHYADDR, mii_id)
 		      | PHYTMAC_BITS(REGADDR, regnum)
 		      | PHYTMAC_BITS(CONST, 2)));
-	phytmac_mdio_idle(pdata);
+	phytmac_v2_mdio_idle(pdata);
 	data = PHYTMAC_READ(pdata, PHYTMAC_MDIO) & 0xffff;
-	phytmac_mdio_idle(pdata);
+	phytmac_v2_mdio_idle(pdata);
 	return data;
 }

-static int phytmac_mdio_data_write_c22(struct phytmac *pdata, int mii_id,
-				       int regnum, u16 data)
+static int phytmac_v2_mdio_data_write_c22(struct phytmac *pdata, int mii_id,
+					  int regnum, u16 data)
 {
 	PHYTMAC_WRITE(pdata, PHYTMAC_MDIO, (PHYTMAC_BITS(CLAUSESEL, PHYTMAC_C22)
 		      | PHYTMAC_BITS(MDCOPS, PHYTMAC_C22_WRITE)
@@ -421,12 +454,12 @@ static int phytmac_mdio_data_write_c22(struct phytmac *pdata, int mii_id,
 		      | PHYTMAC_BITS(REGADDR, regnum)
 		      | PHYTMAC_BITS(VALUE, data)
 		      | PHYTMAC_BITS(CONST, 2)));
-	phytmac_mdio_idle(pdata);
+	phytmac_v2_mdio_idle(pdata);

 	return 0;
 }

-static int phytmac_mdio_data_read_c45(struct phytmac *pdata, int mii_id, int devad, int regnum)
+static int phytmac_v2_mdio_data_read_c45(struct phytmac *pdata, int mii_id, int devad, int regnum)
 {
 	u16 data;

@@ -436,21 +469,21 @@ static int phytmac_mdio_data_read_c45(struct phytmac *pdata, int mii_id, int dev
 		      | PHYTMAC_BITS(REGADDR, devad & 0x1F)
 		      | PHYTMAC_BITS(VALUE, regnum & 0xFFFF)
 		      | PHYTMAC_BITS(CONST, 2)));
-	phytmac_mdio_idle(pdata);
+	phytmac_v2_mdio_idle(pdata);
 	PHYTMAC_WRITE(pdata, PHYTMAC_MDIO, (PHYTMAC_BITS(CLAUSESEL, PHYTMAC_C45)
 		      | PHYTMAC_BITS(MDCOPS, PHYTMAC_C45_READ)
 		      | PHYTMAC_BITS(PHYADDR, mii_id)
 		      | PHYTMAC_BITS(REGADDR, devad & 0x1F)
 		      | PHYTMAC_BITS(VALUE, regnum & 0xFFFF)
 		      | PHYTMAC_BITS(CONST, 2)));
-	phytmac_mdio_idle(pdata);
+	phytmac_v2_mdio_idle(pdata);
 	data = PHYTMAC_READ(pdata, PHYTMAC_MDIO) & 0xffff;
-	phytmac_mdio_idle(pdata);
+	phytmac_v2_mdio_idle(pdata);
 	return data;
 }

-static int phytmac_mdio_data_write_c45(struct phytmac *pdata, int mii_id, int devad,
-				       int regnum, u16 data)
+static int phytmac_v2_mdio_data_write_c45(struct phytmac *pdata, int mii_id, int devad,
+					  int regnum, u16 data)
 {
 	PHYTMAC_WRITE(pdata, PHYTMAC_MDIO, (PHYTMAC_BITS(CLAUSESEL, PHYTMAC_C45)
 		      | PHYTMAC_BITS(MDCOPS, PHYTMAC_C45_ADDR)
@@ -458,24 +491,62 @@ static int phytmac_mdio_data_write_c45(struct phytmac *pdata, int mii_id, int de
 		      | PHYTMAC_BITS(REGADDR, (regnum >> 16) & 0x1F)
 		      | PHYTMAC_BITS(VALUE, regnum & 0xFFFF)
 		      | PHYTMAC_BITS(CONST, 2)));
-	phytmac_mdio_idle(pdata);
+	phytmac_v2_mdio_idle(pdata);
 	PHYTMAC_WRITE(pdata, PHYTMAC_MDIO, (PHYTMAC_BITS(CLAUSESEL, PHYTMAC_C45)
 		      | PHYTMAC_BITS(MDCOPS, PHYTMAC_C45_WRITE)
 		      | PHYTMAC_BITS(PHYADDR, mii_id)
 		      | PHYTMAC_BITS(REGADDR, (regnum >> 16) & 0x1F)
 		      | PHYTMAC_BITS(VALUE, data)
 		      | PHYTMAC_BITS(CONST, 2)));
-	phytmac_mdio_idle(pdata);
+	phytmac_v2_mdio_idle(pdata);

 	return 0;
 }

-static int phytmac_powerup_hw(struct phytmac *pdata, int on)
+static int phytmac_v2_powerup_hw(struct phytmac *pdata, int on)
 {
 	u32 status, data0, data1, rdata1;
 	int ret;
+	acpi_handle handle;
+	union acpi_object args[3];
+	struct acpi_object_list arg_list = {
+		.pointer = args,
+		.count = ARRAY_SIZE(args),
+	};
+	acpi_status acpi_sts;
+	unsigned long long rv;
+
+	if (!(pdata->capacities & PHYTMAC_CAPS_PWCTRL)) {
+		pdata->power_state = on;
+		return 0;
+	}

-	if (pdata->capacities & PHYTMAC_CAPS_LPI) {
+	if (has_acpi_companion(pdata->dev)) {
+		handle = ACPI_HANDLE(pdata->dev);
+
+		netdev_info(pdata->ndev, "set gmac power %s\n",
+			    on == PHYTMAC_POWERON ? "on" : "off");
+		args[0].type = ACPI_TYPE_INTEGER;
+		args[0].integer.value = PHYTMAC_PWCTL_GMAC_ID;
+		args[1].type = ACPI_TYPE_INTEGER;
+		args[1].integer.value = PHYTMAC_PWCTL_DEFAULT_VAL;
+		args[2].type = ACPI_TYPE_INTEGER;
+		args[2].integer.value = PHYTMAC_PWCTL_DEFAULT_VAL;
+
+		if (on == PHYTMAC_POWERON) {
+			acpi_sts = acpi_evaluate_integer(handle, "PPWO", &arg_list, &rv);
+			if (ACPI_FAILURE(acpi_sts))
+				netdev_err(pdata->ndev, "NO PPWO Method\n");
+			if (rv)
+				netdev_err(pdata->ndev, "Failed to power on\n");
+		} else {
+			acpi_sts = acpi_evaluate_integer(handle, "PPWD", &arg_list, &rv);
+			if (ACPI_FAILURE(acpi_sts))
+				netdev_err(pdata->ndev, "NO PPWD Method\n");
+			if (rv)
+				netdev_err(pdata->ndev, "Failed to power off\n");
+		}
+	} else {
 		ret = readx_poll_timeout(PHYTMAC_READ_STAT, pdata, status, !status,
 					 1, PHYTMAC_TIMEOUT);
 		if (ret)
@@ -513,10 +584,10 @@ static int phytmac_powerup_hw(struct phytmac *pdata, int on)
 		rdata1 = PHYTMAC_MHU_READ(pdata, PHYTMAC_MHU_CPP_DATA1);
 		if (rdata1 == data1)
 			netdev_err(pdata->ndev, "gmac power %s success, data1 = %x, rdata1=%x\n",
-				   on ? "up" : "down", data1, rdata1);
+				   on == PHYTMAC_POWERON ? "up" : "down", data1, rdata1);
 		else
 			netdev_err(pdata->ndev, "gmac power %s failed, data1 = %x, rdata1=%x\n",
-				   on ? "up" : "down", data1, rdata1);
+				   on == PHYTMAC_POWERON ? "up" : "down", data1, rdata1);
 	}

 	pdata->power_state = on;
@@ -524,20 +595,32 @@ static int phytmac_powerup_hw(struct phytmac *pdata, int on)
 	return 0;
 }

-static int phytmac_set_wake(struct phytmac *pdata, int wake)
+static int phytmac_v2_set_wake(struct phytmac *pdata, int wake)
 {
 	u16 cmd_id, cmd_subid;
-	u8 wol = (u8)wake;
+	struct phytmac_wol para;
+	u32 wol_type = 0;
+
+	if (wake & PHYTMAC_WAKE_MAGIC)
+		wol_type |= PHYTMAC_BIT(MAGIC);
+	if (wake & PHYTMAC_WAKE_ARP)
+		wol_type |= PHYTMAC_BIT(ARP);
+	if (wake & PHYTMAC_WAKE_UCAST)
+		wol_type |= PHYTMAC_BIT(UCAST);
+	if (wake & PHYTMAC_WAKE_MCAST)
+		wol_type |= PHYTMAC_BIT(MCAST);

 	cmd_id = PHYTMAC_MSG_CMD_SET;
 	cmd_subid = PHYTMAC_MSG_CMD_SET_WOL;
-
-	phytmac_msg_send(pdata, cmd_id, cmd_subid, (void *)(&wol), 1, 1);
+	memset(&para, 0, sizeof(para));
+	para.wol_type = cpu_to_le32(wol_type);
+	para.wake = (u8)wake;
+	phytmac_v2_msg_send(pdata, cmd_id, cmd_subid, (void *)(&para), sizeof(para), 1);

 	return 0;
 }

-static int phytmac_enable_promise(struct phytmac *pdata, int enable)
+static int phytmac_v2_enable_promise(struct phytmac *pdata, int enable)
 {
 	u16 cmd_id, cmd_subid;
 	u8 rxcsum = 0;
@@ -551,12 +634,12 @@ static int phytmac_enable_promise(struct phytmac *pdata, int enable)
 			rxcsum = 1;
 	}

-	phytmac_msg_send(pdata, cmd_id, cmd_subid, (void *)(&rxcsum), 1, 1);
+	phytmac_v2_msg_send(pdata, cmd_id, cmd_subid, (void *)(&rxcsum), 1, 1);

 	return 0;
 }

-static int phytmac_enable_rxcsum(struct phytmac *pdata, int enable)
+static int phytmac_v2_enable_rxcsum(struct phytmac *pdata, int enable)
 {
 	u16 cmd_id, cmd_subid;

@@ -566,12 +649,12 @@ static int phytmac_enable_rxcsum(struct phytmac *pdata, int enable)
 	else
 		cmd_subid = PHYTMAC_MSG_CMD_SET_DISABLE_RXCSUM;

-	phytmac_msg_send(pdata, cmd_id, cmd_subid, NULL, 0, 1);
+	phytmac_v2_msg_send(pdata, cmd_id, cmd_subid, NULL, 0, 1);

 	return 0;
 }

-static int phytmac_enable_txcsum(struct phytmac *pdata, int enable)
+static int phytmac_v2_enable_txcsum(struct phytmac *pdata, int enable)
 {
 	u16 cmd_id, cmd_subid;

@@ -581,12 +664,12 @@ static int phytmac_enable_txcsum(struct phytmac *pdata, int enable)
 	else
 		cmd_subid = PHYTMAC_MSG_CMD_SET_DISABLE_TXCSUM;

-	phytmac_msg_send(pdata, cmd_id, cmd_subid, NULL, 0, 1);
+	phytmac_v2_msg_send(pdata, cmd_id, cmd_subid, NULL, 0, 1);

 	return 0;
 }

-static int phytmac_enable_mdio(struct phytmac *pdata, int enable)
+static int phytmac_v2_enable_mdio(struct phytmac *pdata, int enable)
 {
 	u16 cmd_id, cmd_subid;

@@ -596,12 +679,12 @@ static int phytmac_enable_mdio(struct phytmac *pdata, int enable)
 	else
 		cmd_subid = PHYTMAC_MSG_CMD_SET_DISABLE_MDIO;

-	phytmac_msg_send(pdata, cmd_id, cmd_subid, NULL, 0, 1);
+	phytmac_v2_msg_send(pdata, cmd_id, cmd_subid, NULL, 0, 1);

 	return 0;
 }

-static int phytmac_enable_autoneg(struct phytmac *pdata, int enable)
+static int phytmac_v2_enable_autoneg(struct phytmac *pdata, int enable)
 {
 	u16 cmd_id, cmd_subid;

@@ -611,13 +694,13 @@ static int phytmac_enable_autoneg(struct phytmac *pdata, int enable)
 	else
 		cmd_subid = PHYTMAC_MSG_CMD_SET_DISABLE_AUTONEG;

-	phytmac_msg_send(pdata, cmd_id, cmd_subid, NULL, 0, 1);
+	phytmac_v2_msg_send(pdata, cmd_id, cmd_subid, NULL, 0, 1);

 	pdata->autoneg = enable;
 	return 0;
 }

-static int phytmac_enable_pause(struct phytmac *pdata, int enable)
+static int phytmac_v2_enable_pause(struct phytmac *pdata, int enable)
 {
 	u16 cmd_id, cmd_subid;

@@ -627,12 +710,12 @@ static int phytmac_enable_pause(struct phytmac *pdata, int enable)
 	else
 		cmd_subid = PHYTMAC_MSG_CMD_SET_DISABLE_PAUSE;

-	phytmac_msg_send(pdata, cmd_id, cmd_subid, NULL, 0, 1);
+	phytmac_v2_msg_send(pdata, cmd_id, cmd_subid, NULL, 0, 1);

 	return 0;
 }

-static int phytmac_enable_network(struct phytmac *pdata, int enable, int rx_tx)
+static int phytmac_v2_enable_network(struct phytmac *pdata, int enable, int rx_tx)
 {
 	u16 cmd_id, cmd_subid;

@@ -642,12 +725,12 @@ static int phytmac_enable_network(struct phytmac *pdata, int enable, int rx_tx)
 	else
 		cmd_subid = PHYTMAC_MSG_CMD_SET_DISABLE_NETWORK;

-	phytmac_msg_send(pdata, cmd_id, cmd_subid, NULL, 0, 1);
+	phytmac_v2_msg_send(pdata, cmd_id, cmd_subid, NULL, 0, 1);

 	return 0;
 }

-static int phytmac_add_fdir_entry(struct phytmac *pdata, struct ethtool_rx_flow_spec *rx_flow)
+static int phytmac_v2_add_fdir_entry(struct phytmac *pdata, struct ethtool_rx_flow_spec *rx_flow)
 {
 	struct ethtool_tcpip4_spec *tp4sp_v, *tp4sp_m;
 	struct phytmac_fdir_info fdir;
@@ -675,19 +758,19 @@ static int phytmac_add_fdir_entry(struct phytmac *pdata, struct ethtool_rx_flow_
 		fdir.srcport_mask = tp4sp_m->psrc;
 	}

-	fdir.location = rx_flow->location;
-	fdir.queue = rx_flow->ring_cookie;
+	fdir.location = (u8)(rx_flow->location);
+	fdir.queue = (u8)(rx_flow->ring_cookie);

 	if (fdir.ipsrc_en || fdir.ipdst_en || fdir.port_en) {
 		cmd_id = PHYTMAC_MSG_CMD_SET;
 		cmd_subid = PHYTMAC_MSG_CMD_SET_ADD_FDIR;
-		phytmac_msg_send(pdata, cmd_id, cmd_subid, (void *)(&fdir), sizeof(fdir), 1);
+		phytmac_v2_msg_send(pdata, cmd_id, cmd_subid, (void *)(&fdir), sizeof(fdir), 1);
 	}

 	return 0;
 }

-static int phytmac_del_fdir_entry(struct phytmac *pdata, struct ethtool_rx_flow_spec *rx_flow)
+static int phytmac_v2_del_fdir_entry(struct phytmac *pdata, struct ethtool_rx_flow_spec *rx_flow)
 {
 	struct phytmac_fdir_info fdir;
 	u16 cmd_id, cmd_subid;
@@ -695,21 +778,21 @@ static int phytmac_del_fdir_entry(struct phytmac *pdata, struct ethtool_rx_flow_
 	memset(&fdir, 0, sizeof(fdir));
 	cmd_id = PHYTMAC_MSG_CMD_SET;
 	cmd_subid = PHYTMAC_MSG_CMD_SET_DEL_FDIR;
-	fdir.location = (u8)rx_flow->location;
-	phytmac_msg_send(pdata, cmd_id, cmd_subid, (void *)(&fdir), sizeof(fdir), 1);
+	fdir.location = (u8)(rx_flow->location);
+	phytmac_v2_msg_send(pdata, cmd_id, cmd_subid, (void *)(&fdir), sizeof(fdir), 1);

 	return 0;
 }

-static void phytmac_tx_start(struct phytmac_queue *queue)
+static void phytmac_v2_tx_start(struct phytmac_queue *queue)
 {
 	struct phytmac *pdata = queue->pdata;

-	PHYTMAC_WRITE(pdata, PHYTMAC_TAIL_PTR(queue->index), queue->tx_tail);
+	PHYTMAC_WRITE(pdata, PHYTMAC_TX_PTR(queue->index), queue->tx_tail);
 	queue->tx_xmit_more = 0;
 }

-static u32 phytmac_get_irq_mask(u32 mask)
+static u32 phytmac_v2_get_irq_mask(u32 mask)
 {
 	u32 value = 0;

@@ -722,7 +805,7 @@ static u32 phytmac_get_irq_mask(u32 mask)
 	return value;
 }

-static u32 phytmac_get_irq_status(u32 value)
+static u32 phytmac_v2_get_irq_status(u32 value)
 {
 	u32 status = 0;

@@ -735,111 +818,124 @@ static u32 phytmac_get_irq_status(u32 value)
 	return status;
 }

-static void phytmac_enable_irq(struct phytmac *pdata,
-			       int queue_index, u32 mask)
+static void phytmac_v2_enable_irq(struct phytmac *pdata,
+				  int queue_index, u32 mask)
 {
 	u32 value;

-	value = phytmac_get_irq_mask(mask);
+	value = phytmac_v2_get_irq_mask(mask);
 	PHYTMAC_WRITE(pdata, PHYTMAC_INT_ER(queue_index), value);
 }

-static void phytmac_disable_irq(struct phytmac *pdata,
-				int queue_index, u32 mask)
+static void phytmac_v2_disable_irq(struct phytmac *pdata,
+				   int queue_index, u32 mask)
 {
 	u32 value;

-	value = phytmac_get_irq_mask(mask);
+	value = phytmac_v2_get_irq_mask(mask);
 	PHYTMAC_WRITE(pdata, PHYTMAC_INT_DR(queue_index), value);
 }

-static void phytmac_clear_irq(struct phytmac *pdata,
-			      int queue_index, u32 mask)
+static void phytmac_v2_clear_irq(struct phytmac *pdata,
+				 int queue_index, u32 mask)
 {
 	u32 value;

-	value = phytmac_get_irq_mask(mask);
+	value = phytmac_v2_get_irq_mask(mask);
 	PHYTMAC_WRITE(pdata, PHYTMAC_INT_SR(queue_index), value);
 }

-static unsigned int phytmac_get_irq(struct phytmac *pdata, int queue_index)
+static unsigned int phytmac_v2_get_irq(struct phytmac *pdata, int queue_index)
 {
 	u32 status;
 	u32 value;

 	value = PHYTMAC_READ(pdata, PHYTMAC_INT_SR(queue_index));
-	status = phytmac_get_irq_status(value);
+	status = phytmac_v2_get_irq_status(value);

 	return status;
 }

-static void phytmac_interface_config(struct phytmac *pdata, unsigned int mode,
-				     const struct phylink_link_state *state)
+static void phytmac_v2_interface_config(struct phytmac *pdata, unsigned int mode,
+					const struct phylink_link_state *state)
 {
 	struct phytmac_interface_info para;
 	u16 cmd_id, cmd_subid;
+	u8 autoneg = 0;
+
+	if (state->interface == PHY_INTERFACE_MODE_SGMII) {
+		if (mode == MLO_AN_FIXED)
+			autoneg = 0;
+		else
+			autoneg = 1;
+	}
+
+	if (state->interface == PHY_INTERFACE_MODE_1000BASEX)
+		autoneg = 1;
+	if (state->interface == PHY_INTERFACE_MODE_2500BASEX)
+		autoneg = 0;

 	memset(&para, 0, sizeof(para));
 	cmd_id = PHYTMAC_MSG_CMD_SET;
-	cmd_subid = PHYTMAC_MSG_CMD_SET_MAC_CONFIG;
-	para.interface = state->interface;
-	para.autoneg = (mode == MLO_AN_FIXED ? 0 : 1);
+	cmd_subid = PHYTMAC_MSG_CMD_SET_INIT_MAC_CONFIG;
+	para.interface = pdata->phytmac_v2_interface;
+	para.autoneg = autoneg;
 	para.speed = state->speed;
 	para.duplex = state->duplex;
 	pdata->autoneg = para.autoneg;
-	phytmac_msg_send(pdata, cmd_id, cmd_subid, (void *)(&para), sizeof(para), 1);
+	phytmac_v2_msg_send(pdata, cmd_id, cmd_subid, (void *)(&para), sizeof(para), 1);
 }

-static int phytmac_interface_linkup(struct phytmac *pdata, phy_interface_t interface,
-				    int speed, int duplex)
+static int phytmac_v2_interface_linkup(struct phytmac *pdata, phy_interface_t interface,
+				       int speed, int duplex)
 {
 	struct phytmac_interface_info para;
 	u16 cmd_id, cmd_subid;

+	if (interface == PHY_INTERFACE_MODE_SGMII) {
+		if (speed == SPEED_2500)
+			pdata->autoneg = 0;
+	}
+
 	memset(&para, 0, sizeof(para));
 	cmd_id = PHYTMAC_MSG_CMD_SET;
 	cmd_subid = PHYTMAC_MSG_CMD_SET_MAC_LINK_CONFIG;
-	para.interface = interface;
+	para.interface = pdata->phytmac_v2_interface;
 	para.duplex = duplex;
 	para.speed = speed;
 	para.autoneg = pdata->autoneg;
-	phytmac_msg_send(pdata, cmd_id, cmd_subid, (void *)(&para), sizeof(para), 1);
+	phytmac_v2_msg_send(pdata, cmd_id, cmd_subid, (void *)(&para), sizeof(para), 1);

 	return 0;
 }

-static int phytmac_interface_linkdown(struct phytmac *pdata)
+static int phytmac_v2_interface_linkdown(struct phytmac *pdata)
 {
 	return 0;
 }

-static int phytmac_pcs_linkup(struct phytmac *pdata, phy_interface_t interface,
-			      int speed, int duplex)
+static int phytmac_v2_pcs_linkup(struct phytmac *pdata, phy_interface_t interface,
+				 int speed, int duplex)
 {
-	struct phytmac_interface_info para;
 	u16 cmd_id, cmd_subid;

 	if (interface == PHY_INTERFACE_MODE_USXGMII ||
 	    interface == PHY_INTERFACE_MODE_10GBASER) {
-		memset(&para, 0, sizeof(para));
 		cmd_id = PHYTMAC_MSG_CMD_SET;
 		cmd_subid = PHYTMAC_MSG_CMD_SET_PCS_LINK_UP;
-		para.interface = interface;
-		para.duplex = duplex;
-		para.speed = speed;
-		para.autoneg = 0;
-		phytmac_msg_send(pdata, cmd_id, cmd_subid, (void *)(&para), sizeof(para), 1);
+
+		phytmac_v2_msg_send(pdata, cmd_id, cmd_subid, NULL, 0, 0);
 	}

 	return 0;
 }

-static int phytmac_pcs_linkdown(struct phytmac *pdata)
+static int phytmac_v2_pcs_linkdown(struct phytmac *pdata)
 {
 	return 0;
 }

-static unsigned int phytmac_pcs_get_link(struct phytmac *pdata, phy_interface_t interface)
+static unsigned int phytmac_v2_pcs_get_link(struct phytmac *pdata, phy_interface_t interface)
 {
 	if (interface == PHY_INTERFACE_MODE_SGMII ||
 	    interface == PHY_INTERFACE_MODE_1000BASEX ||
@@ -852,8 +948,8 @@ static unsigned int phytmac_pcs_get_link(struct phytmac *pdata, phy_interface_t
 	return 0;
 }

-static  unsigned int phytmac_tx_map_desc(struct phytmac_queue *queue,
-					 u32 tx_tail, struct packet_info *packet)
+static unsigned int phytmac_v2_tx_map_desc(struct phytmac_queue *queue,
+					   u32 tx_tail, struct packet_info *packet)
 {
 	unsigned int i, ctrl;
 	struct phytmac *pdata = queue->pdata;
@@ -896,8 +992,8 @@ static  unsigned int phytmac_tx_map_desc(struct phytmac_queue *queue,
 	return 0;
 }

-static void phytmac_init_rx_map_desc(struct phytmac_queue *queue,
-				     u32 index)
+static void phytmac_v2_init_rx_map_desc(struct phytmac_queue *queue,
+					u32 index)
 {
 	struct phytmac_dma_desc *desc;

@@ -909,7 +1005,7 @@ static void phytmac_init_rx_map_desc(struct phytmac_queue *queue,
 	desc->desc0 |= PHYTMAC_BIT(RXUSED);
 }

-static unsigned int phytmac_rx_map_desc(struct phytmac_queue *queue, u32 index, dma_addr_t addr)
+static unsigned int phytmac_v2_rx_map_desc(struct phytmac_queue *queue, u32 index, dma_addr_t addr)
 {
 	struct phytmac *pdata = queue->pdata;
 	struct phytmac_dma_desc *desc;
@@ -922,19 +1018,21 @@ static unsigned int phytmac_rx_map_desc(struct phytmac_queue *queue, u32 index,
 		desc->desc1 = 0;
 		desc->desc2 = upper_32_bits(addr);
 		/* Make newly descriptor to hardware */
-		dma_wmb();
+		if (!(pdata->capacities & PHYTMAC_CAPS_RXPTR))
+			dma_wmb();
 		desc->desc0 = lower_32_bits(addr);
 	} else {
 		desc->desc1 = 0;
 		/* make newly descriptor to hardware */
-		dma_wmb();
+		if (!(pdata->capacities & PHYTMAC_CAPS_RXPTR))
+			dma_wmb();
 		desc->desc0 &= ~PHYTMAC_BIT(RXUSED);
 	}

 	return 0;
 }

-static unsigned int phytmac_zero_rx_desc_addr(struct phytmac_dma_desc *desc)
+static unsigned int phytmac_v2_zero_rx_desc_addr(struct phytmac_dma_desc *desc)
 {
 	desc->desc2 = 0;
 	desc->desc0 = PHYTMAC_BIT(RXUSED);
@@ -942,12 +1040,29 @@ static unsigned int phytmac_zero_rx_desc_addr(struct phytmac_dma_desc *desc)
 	return 0;
 }

-static int phytmac_tx_complete(const struct phytmac_dma_desc *desc)
+static unsigned int phytmac_v2_zero_tx_desc(struct phytmac_dma_desc *desc)
+{
+	desc->desc2 = 0;
+	desc->desc0 = 0;
+	desc->desc1 &= ~PHYTMAC_BIT(TXUSED);
+
+	return 0;
+}
+
+static void phytmac_v2_update_rx_tail(struct phytmac_queue *queue)
+{
+	struct phytmac *pdata = queue->pdata;
+
+	if (pdata->capacities & PHYTMAC_CAPS_RXPTR)
+		PHYTMAC_WRITE(pdata, PHYTMAC_RX_PTR(queue->index), queue->rx_head);
+}
+
+static int phytmac_v2_tx_complete(const struct phytmac_dma_desc *desc)
 {
 	return PHYTMAC_GET_BITS(desc->desc1, TXUSED);
 }

-static bool phytmac_rx_complete(const struct phytmac_dma_desc *desc)
+static bool phytmac_v2_rx_complete(const struct phytmac_dma_desc *desc)
 {
 	dma_addr_t addr;
 	bool used;
@@ -962,7 +1077,7 @@ static bool phytmac_rx_complete(const struct phytmac_dma_desc *desc)
 		return false;
 }

-static int phytmac_rx_pkt_len(struct phytmac *pdata, const struct phytmac_dma_desc *desc)
+static int phytmac_v2_rx_pkt_len(struct phytmac *pdata, const struct phytmac_dma_desc *desc)
 {
 	if (pdata->capacities & PHYTMAC_CAPS_JUMBO)
 		return desc->desc1 & PHYTMAC_RXJFRMLEN_MASK;
@@ -970,7 +1085,7 @@ static int phytmac_rx_pkt_len(struct phytmac *pdata, const struct phytmac_dma_de
 		return desc->desc1 & PHYTMAC_RXFRMLEN_MASK;
 }

-static bool phytmac_rx_checksum(const struct phytmac_dma_desc *desc)
+static bool phytmac_v2_rx_checksum(const struct phytmac_dma_desc *desc)
 {
 	u32 value = desc->desc1;
 	u32 check = value >> PHYTMAC_RXCSUM_INDEX & 0x3;
@@ -978,28 +1093,28 @@ static bool phytmac_rx_checksum(const struct phytmac_dma_desc *desc)
 	return (check == PHYTMAC_RXCSUM_IP_TCP || check == PHYTMAC_RXCSUM_IP_UDP);
 }

-static bool phytmac_rx_single_buffer(const struct phytmac_dma_desc *desc)
+static bool phytmac_v2_rx_single_buffer(const struct phytmac_dma_desc *desc)
 {
 	u32 value = desc->desc1;

 	return ((value & PHYTMAC_BIT(RXSOF)) && (value & PHYTMAC_BIT(RXEOF)));
 }

-static bool phytmac_rx_sof(const struct phytmac_dma_desc *desc)
+static bool phytmac_v2_rx_sof(const struct phytmac_dma_desc *desc)
 {
 	u32 value = desc->desc1;

 	return (value & PHYTMAC_BIT(RXSOF));
 }

-static bool phytmac_rx_eof(const struct phytmac_dma_desc *desc)
+static bool phytmac_v2_rx_eof(const struct phytmac_dma_desc *desc)
 {
 	u32 value = desc->desc1;

 	return (value & PHYTMAC_BIT(RXEOF));
 }

-static void phytmac_clear_rx_desc(struct phytmac_queue *queue, int begin, int end)
+static void phytmac_v2_clear_rx_desc(struct phytmac_queue *queue, int begin, int end)
 {
 	unsigned int frag;
 	unsigned int tmp = end;
@@ -1014,7 +1129,7 @@ static void phytmac_clear_rx_desc(struct phytmac_queue *queue, int begin, int en
 	}
 }

-static void phytmac_clear_tx_desc(struct phytmac_queue *queue)
+static void phytmac_v2_clear_tx_desc(struct phytmac_queue *queue)
 {
 	struct phytmac *pdata = queue->pdata;
 	struct phytmac_dma_desc *desc = NULL;
@@ -1031,10 +1146,10 @@ static void phytmac_clear_tx_desc(struct phytmac_queue *queue)
 		desc->desc1 = PHYTMAC_BIT(TXUSED);
 	}
 	desc->desc1 |= PHYTMAC_BIT(TXWRAP);
-	PHYTMAC_WRITE(pdata, PHYTMAC_TAIL_PTR(queue->index), queue->tx_tail);
+	PHYTMAC_WRITE(pdata, PHYTMAC_TX_PTR(queue->index), queue->tx_tail);
 }

-static void phytmac_get_time(struct phytmac *pdata, struct timespec64 *ts)
+static void phytmac_v2_get_time(struct phytmac *pdata, struct timespec64 *ts)
 {
 	u32 ns, secl, sech;

@@ -1046,7 +1161,7 @@ static void phytmac_get_time(struct phytmac *pdata, struct timespec64 *ts)
 	ts->tv_sec = (((u64)sech << 32) | secl) & TIMER_SEC_MAX_VAL;
 }

-void phytmac_set_time(struct phytmac *pdata, time64_t sec, long nsec)
+static void phytmac_v2_set_time(struct phytmac *pdata, time64_t sec, long nsec)
 {
 	u32 secl, sech;

@@ -1059,7 +1174,7 @@ void phytmac_set_time(struct phytmac *pdata, time64_t sec, long nsec)
 	PHYTMAC_WRITE(pdata, PHYTMAC_TIMER_NSEC, nsec);
 }

-void phytmac_clear_time(struct phytmac *pdata)
+static void phytmac_v2_clear_time(struct phytmac *pdata)
 {
 	u32 value;

@@ -1077,7 +1192,7 @@ void phytmac_clear_time(struct phytmac *pdata)
 	PHYTMAC_WRITE(pdata, PHYTMAC_TIMER_ADJUST, 0);
 }

-int phytmac_set_tsmode(struct phytmac *pdata, struct ts_ctrl *ctrl)
+static int phytmac_v2_set_tsmode(struct phytmac *pdata, struct ts_ctrl *ctrl)
 {
 	u16 cmd_id, cmd_subid;
 	struct phytmac_ts_config para;
@@ -1087,12 +1202,12 @@ int phytmac_set_tsmode(struct phytmac *pdata, struct ts_ctrl *ctrl)
 	para.tx_mode = ctrl->tx_control;
 	para.rx_mode = ctrl->rx_control;
 	para.one_step = ctrl->one_step;
-	phytmac_msg_send(pdata, cmd_id, cmd_subid, (void *)(&para), sizeof(para), 1);
+	phytmac_v2_msg_send(pdata, cmd_id, cmd_subid, (void *)(&para), sizeof(para), 1);

 	return 0;
 }

-static int phytmac_set_tsincr(struct phytmac *pdata, struct ts_incr *incr)
+static int phytmac_v2_set_tsincr(struct phytmac *pdata, struct ts_incr *incr)
 {
 	u32 value;

@@ -1103,17 +1218,17 @@ static int phytmac_set_tsincr(struct phytmac *pdata, struct ts_incr *incr)
 	return 0;
 }

-static void phytmac_ptp_init_hw(struct phytmac *pdata)
+static void phytmac_v2_ptp_init_hw(struct phytmac *pdata)
 {
 	struct timespec64 ts;

 	ts = ns_to_timespec64(ktime_to_ns(ktime_get_real()));
-	phytmac_set_time(pdata, ts.tv_sec, ts.tv_nsec);
+	phytmac_v2_set_time(pdata, ts.tv_sec, ts.tv_nsec);

-	phytmac_set_tsincr(pdata, &pdata->ts_incr);
+	phytmac_v2_set_tsincr(pdata, &pdata->ts_incr);
 }

-static int phytmac_adjust_fine(struct phytmac *pdata, long ppm, bool negative)
+static int phytmac_v2_adjust_fine(struct phytmac *pdata, long ppm, bool negative)
 {
 	struct ts_incr ts_incr;
 	u32 tmp;
@@ -1133,22 +1248,25 @@ static int phytmac_adjust_fine(struct phytmac *pdata, long ppm, bool negative)
 			& ((1 << PHYTMAC_INCR_NSEC_WIDTH) - 1);
 	ts_incr.sub_ns = adj & ((1 << PHYTMAC_INCR_SNSEC_WIDTH) - 1);

-	phytmac_set_tsincr(pdata, &ts_incr);
+	phytmac_v2_set_tsincr(pdata, &ts_incr);

 	return 0;
 }

-int phytmac_adjust_time(struct phytmac *pdata, s64 delta, int neg)
+static int phytmac_v2_adjust_time(struct phytmac *pdata, s64 delta, int neg)
 {
 	u32 adj;

 	if (delta > PHYTMAC_ASEC_MAX) {
 		struct timespec64 now, then;

-		then = ns_to_timespec64(delta);
-		phytmac_get_time(pdata, &now);
+		if (neg)
+			then = ns_to_timespec64(-delta);
+		else
+			then = ns_to_timespec64(delta);
+		phytmac_v2_get_time(pdata, &now);
 		now = timespec64_add(now, then);
-		phytmac_set_time(pdata, now.tv_sec, now.tv_nsec);
+		phytmac_v2_set_time(pdata, now.tv_sec, now.tv_nsec);
 	} else {
 		adj = (neg << PHYTMAC_AADD_INDEX) | delta;
 		PHYTMAC_WRITE(pdata, PHYTMAC_TIMER_ADJUST, adj);
@@ -1157,7 +1275,7 @@ int phytmac_adjust_time(struct phytmac *pdata, s64 delta, int neg)
 	return 0;
 }

-static int phytmac_ts_valid(struct phytmac *pdata, struct phytmac_dma_desc *desc, int direction)
+static int phytmac_v2_ts_valid(struct phytmac *pdata, struct phytmac_dma_desc *desc, int direction)
 {
 	int ts_valid = 0;

@@ -1168,7 +1286,7 @@ static int phytmac_ts_valid(struct phytmac *pdata, struct phytmac_dma_desc *desc
 	return ts_valid;
 }

-static void phytmac_get_dma_ts(struct phytmac *pdata, u32 ts_1, u32 ts_2, struct timespec64 *ts)
+static void phytmac_v2_get_dma_ts(struct phytmac *pdata, u32 ts_1, u32 ts_2, struct timespec64 *ts)
 {
 	struct timespec64 ts2;

@@ -1176,7 +1294,7 @@ static void phytmac_get_dma_ts(struct phytmac *pdata, u32 ts_1, u32 ts_2, struct
 				PHYTMAC_GET_BITS(ts_1, TS_SECL);
 	ts->tv_nsec = PHYTMAC_GET_BITS(ts_1, TS_NSEC);

-	phytmac_get_time(pdata, &ts2);
+	phytmac_v2_get_time(pdata, &ts2);

 	if (((ts->tv_sec ^ ts2.tv_sec) & (PHYTMAC_TS_SEC_TOP >> 1)) != 0)
 		ts->tv_sec -= PHYTMAC_TS_SEC_TOP;
@@ -1184,80 +1302,82 @@ static void phytmac_get_dma_ts(struct phytmac *pdata, u32 ts_1, u32 ts_2, struct
 	ts->tv_sec += (ts2.tv_sec & (~PHYTMAC_TS_SEC_MASK));
 }

-static unsigned int phytmac_get_ts_rate(struct phytmac *pdata)
+static unsigned int phytmac_v2_get_ts_rate(struct phytmac *pdata)
 {
 	return 300000000;
 }

 struct phytmac_hw_if phytmac_2p0_hw = {
-	.init_msg_ring = phytmac_init_msg_ring,
-	.reset_hw = phytmac_reset_hw,
-	.init_hw = phytmac_init_hw,
-	.init_ring_hw = phytmac_init_ring_hw,
-	.get_feature = phytmac_get_feature_all,
-	.get_regs = phytmac_get_regs,
-	.get_stats = phytmac_get_hw_stats,
-	.set_mac_address = phytmac_set_mac_addr,
-	.get_mac_address = phytmac_get_mac_addr,
-	.mdio_read = phytmac_mdio_data_read_c22,
-	.mdio_write = phytmac_mdio_data_write_c22,
-	.mdio_read_c45 = phytmac_mdio_data_read_c45,
-	.mdio_write_c45 = phytmac_mdio_data_write_c45,
-	.poweron = phytmac_powerup_hw,
-	.set_wol = phytmac_set_wake,
-	.enable_promise = phytmac_enable_promise,
-	.enable_multicast = phytmac_enable_multicast,
-	.set_hash_table = phytmac_set_mc_hash,
-	.enable_rx_csum = phytmac_enable_rxcsum,
-	.enable_tx_csum = phytmac_enable_txcsum,
-	.enable_mdio_control = phytmac_enable_mdio,
-	.enable_autoneg = phytmac_enable_autoneg,
-	.enable_pause = phytmac_enable_pause,
-	.enable_network = phytmac_enable_network,
-	.add_fdir_entry = phytmac_add_fdir_entry,
-	.del_fdir_entry = phytmac_del_fdir_entry,
+	.init_msg_ring = phytmac_v2_init_msg_ring,
+	.reset_hw = phytmac_v2_reset_hw,
+	.init_hw = phytmac_v2_init_hw,
+	.init_ring_hw = phytmac_v2_init_ring_hw,
+	.get_feature = phytmac_v2_get_feature_all,
+	.get_regs = phytmac_v2_get_regs,
+	.get_stats = phytmac_v2_get_hw_stats,
+	.set_mac_address = phytmac_v2_set_mac_addr,
+	.get_mac_address = phytmac_v2_get_mac_addr,
+	.mdio_read = phytmac_v2_mdio_data_read_c22,
+	.mdio_write = phytmac_v2_mdio_data_write_c22,
+	.mdio_read_c45 = phytmac_v2_mdio_data_read_c45,
+	.mdio_write_c45 = phytmac_v2_mdio_data_write_c45,
+	.poweron = phytmac_v2_powerup_hw,
+	.set_wol = phytmac_v2_set_wake,
+	.enable_promise = phytmac_v2_enable_promise,
+	.enable_multicast = phytmac_v2_enable_multicast,
+	.set_hash_table = phytmac_v2_set_mc_hash,
+	.enable_rx_csum = phytmac_v2_enable_rxcsum,
+	.enable_tx_csum = phytmac_v2_enable_txcsum,
+	.enable_mdio_control = phytmac_v2_enable_mdio,
+	.enable_autoneg = phytmac_v2_enable_autoneg,
+	.enable_pause = phytmac_v2_enable_pause,
+	.enable_network = phytmac_v2_enable_network,
+	.add_fdir_entry = phytmac_v2_add_fdir_entry,
+	.del_fdir_entry = phytmac_v2_del_fdir_entry,

 	/* mac config */
-	.mac_config = phytmac_interface_config,
-	.mac_linkup = phytmac_interface_linkup,
-	.mac_linkdown = phytmac_interface_linkdown,
-	.pcs_linkup = phytmac_pcs_linkup,
-	.pcs_linkdown = phytmac_pcs_linkdown,
-	.get_link = phytmac_pcs_get_link,
+	.mac_config = phytmac_v2_interface_config,
+	.mac_linkup = phytmac_v2_interface_linkup,
+	.mac_linkdown = phytmac_v2_interface_linkdown,
+	.pcs_linkup = phytmac_v2_pcs_linkup,
+	.pcs_linkdown = phytmac_v2_pcs_linkdown,
+	.get_link = phytmac_v2_pcs_get_link,

 	/* irq */
-	.enable_irq = phytmac_enable_irq,
-	.disable_irq = phytmac_disable_irq,
-	.clear_irq = phytmac_clear_irq,
-	.get_irq = phytmac_get_irq,
+	.enable_irq = phytmac_v2_enable_irq,
+	.disable_irq = phytmac_v2_disable_irq,
+	.clear_irq = phytmac_v2_clear_irq,
+	.get_irq = phytmac_v2_get_irq,

 	/* tx and rx */
-	.tx_map = phytmac_tx_map_desc,
-	.transmit = phytmac_tx_start,
-	.tx_complete = phytmac_tx_complete,
-	.rx_complete = phytmac_rx_complete,
-	.get_rx_pkt_len = phytmac_rx_pkt_len,
-	.init_rx_map = phytmac_init_rx_map_desc,
-	.rx_map = phytmac_rx_map_desc,
-	.rx_checksum = phytmac_rx_checksum,
-	.rx_single_buffer = phytmac_rx_single_buffer,
-	.rx_pkt_start = phytmac_rx_sof,
-	.rx_pkt_end = phytmac_rx_eof,
-	.clear_rx_desc = phytmac_clear_rx_desc,
-	.clear_tx_desc = phytmac_clear_tx_desc,
-	.zero_rx_desc_addr = phytmac_zero_rx_desc_addr,
+	.tx_map = phytmac_v2_tx_map_desc,
+	.transmit = phytmac_v2_tx_start,
+	.update_rx_tail = phytmac_v2_update_rx_tail,
+	.tx_complete = phytmac_v2_tx_complete,
+	.rx_complete = phytmac_v2_rx_complete,
+	.get_rx_pkt_len = phytmac_v2_rx_pkt_len,
+	.init_rx_map = phytmac_v2_init_rx_map_desc,
+	.rx_map = phytmac_v2_rx_map_desc,
+	.rx_checksum = phytmac_v2_rx_checksum,
+	.rx_single_buffer = phytmac_v2_rx_single_buffer,
+	.rx_pkt_start = phytmac_v2_rx_sof,
+	.rx_pkt_end = phytmac_v2_rx_eof,
+	.clear_rx_desc = phytmac_v2_clear_rx_desc,
+	.clear_tx_desc = phytmac_v2_clear_tx_desc,
+	.zero_rx_desc_addr = phytmac_v2_zero_rx_desc_addr,
+	.zero_tx_desc = phytmac_v2_zero_tx_desc,

 	/* ptp */
-	.init_ts_hw = phytmac_ptp_init_hw,
-	.set_time = phytmac_set_time,
-	.clear_time = phytmac_clear_time,
-	.get_time = phytmac_get_time,
-	.set_ts_config = phytmac_set_tsmode,
-	.set_incr = phytmac_set_tsincr,
-	.adjust_fine = phytmac_adjust_fine,
-	.adjust_time = phytmac_adjust_time,
-	.ts_valid = phytmac_ts_valid,
-	.get_timestamp = phytmac_get_dma_ts,
-	.get_ts_rate = phytmac_get_ts_rate,
+	.init_ts_hw = phytmac_v2_ptp_init_hw,
+	.set_time = phytmac_v2_set_time,
+	.clear_time = phytmac_v2_clear_time,
+	.get_time = phytmac_v2_get_time,
+	.set_ts_config = phytmac_v2_set_tsmode,
+	.set_incr = phytmac_v2_set_tsincr,
+	.adjust_fine = phytmac_v2_adjust_fine,
+	.adjust_time = phytmac_v2_adjust_time,
+	.ts_valid = phytmac_v2_ts_valid,
+	.get_timestamp = phytmac_v2_get_dma_ts,
+	.get_ts_rate = phytmac_v2_get_ts_rate,
 };
 EXPORT_SYMBOL_GPL(phytmac_2p0_hw);
diff --git a/drivers/net/ethernet/phytium/phytmac_v2.h b/drivers/net/ethernet/phytium/phytmac_v2.h
index 92e4806ac2c1..d2da4acb69a7 100644
--- a/drivers/net/ethernet/phytium/phytmac_v2.h
+++ b/drivers/net/ethernet/phytium/phytmac_v2.h
@@ -1,11 +1,15 @@
 /* SPDX-License-Identifier: GPL-2.0-only */
+/* Copyright(c) 2022 - 2025 Phytium Technology Co., Ltd. */
+
 #ifndef _PHYTMAC_V2_H
 #define _PHYTMAC_V2_H

 extern struct phytmac_hw_if phytmac_2p0_hw;

+#define PHYTMAC_CMD_PRC_COMPLETED	0x1
 #define PHYTMAC_MSG_SRAM_SIZE	4096
-#define MSG_HDR_LEN		8
+#define MSG_HDR_LEN				8
+#define READ_REG_NUM_MAX		16

 #define PHYTMAC_TX_MSG_HEAD				0x000
 #define PHYTMAC_TX_MSG_TAIL				0x004
@@ -83,7 +87,8 @@ extern struct phytmac_hw_if phytmac_2p0_hw;
 #define TIMER_SEC_MAX_VAL (((u64)1 << PHYTMAC_TIMER_SEC_WIDTH) - 1)
 #define TIMER_NSEC_MAX_VAL ((1 << PHYTMAC_TIMER_NSEC_WIDTH) - 1)

-#define PHYTMAC_TAIL_PTR(i)				(0x0100 + ((i) * 4))
+#define PHYTMAC_TX_PTR(i)				(0x0100 + ((i) * 4))
+#define PHYTMAC_RX_PTR(i)				(0x0030 + ((i) * 4))
 #define PHYTMAC_INT_ER(i)				(0x0140 + ((i) * 4))
 #define PHYTMAC_INT_DR(i)				(0x0180 + ((i) * 4))
 #define PHYTMAC_INT_MR(i)				(0x01c0 + ((i) * 4))
@@ -200,15 +205,38 @@ extern struct phytmac_hw_if phytmac_2p0_hw;
 #define PHYTMAC_TS_SEC_MASK			0x3f
 #define PHYTMAC_TS_SEC_TOP			0x40

+/* WOL register */
+#define PHYTMAC_ARP_IP_INDEX		0
+#define PHYTMAC_ARP_IP_WIDTH		16
+#define PHYTMAC_MAGIC_INDEX			16
+#define PHYTMAC_MAGIC_WIDTH			1
+#define PHYTMAC_ARP_INDEX			17
+#define PHYTMAC_ARP_WIDTH			1
+#define PHYTMAC_UCAST_INDEX			18
+#define PHYTMAC_UCAST_WIDTH			1
+#define PHYTMAC_MCAST_INDEX			19
+#define PHYTMAC_MCAST_WIDTH			1
+
 #define HW_DMA_CAP_64B		0x1
 #define HW_DMA_CAP_CSUM		0x2
 #define HW_DMA_CAP_PTP		0x4
-#define HW_DMA_CAP_DDW64	0x8
-#define HW_DMA_CAP_DDW128	0x10
+#define HW_DMA_CAP_DDW32	0x8
+#define HW_DMA_CAP_DDW64	0x10
+#define HW_DMA_CAP_DDW128	0x20

+#define PHYTMAC_DBW32				1
 #define PHYTMAC_DBW64				2
 #define PHYTMAC_DBW128				4

+#define PHYTMAC_CLK_DIV8	0
+#define PHYTMAC_CLK_DIV16	1
+#define PHYTMAC_CLK_DIV32	2
+#define PHYTMAC_CLK_DIV48	3
+#define PHYTMAC_CLK_DIV64	4
+#define PHYTMAC_CLK_DIV96	5
+#define PHYTMAC_CLK_DIV128	6
+#define PHYTMAC_CLK_DIV224	7
+
 enum phytmac_msg_cmd_id {
 	PHYTMAC_MSG_CMD_DEFAULT = 0,
 	PHYTMAC_MSG_CMD_SET,
@@ -228,7 +256,7 @@ enum phytmac_set_subid {
 	PHYTMAC_MSG_CMD_SET_INIT_RING = 1,
 	PHYTMAC_MSG_CMD_SET_INIT_TX_RING = 2,
 	PHYTMAC_MSG_CMD_SET_INIT_RX_RING = 3,
-	PHYTMAC_MSG_CMD_SET_MAC_CONFIG = 4,
+	PHYTMAC_MSG_CMD_SET_INIT_MAC_CONFIG = 4,
 	PHYTMAC_MSG_CMD_SET_ADDR = 5,
 	PHYTMAC_MSG_CMD_SET_DMA_RX_BUFSIZE = 6,
 	PHYTMAC_MSG_CMD_SET_DMA = 7,
@@ -269,6 +297,13 @@ enum phytmac_set_subid {
 	PHYTMAC_MSG_CMD_SET_DISABLE_AUTONEG = 42,
 	PHYTMAC_MSG_CMD_SET_RX_DATA_OFFSET = 43,
 	PHYTMAC_MSG_CMD_SET_WOL = 44,
+	PHYTMAC_MSG_CMD_SET_ENABLE_RSC = 45,
+	PHYTMAC_MSG_CMD_SET_DISABLE_RSC = 46,
+	PHYTMAC_MSG_CMD_SET_ENABLE_TX_START = 47,
+	PHYTMAC_MSG_CMD_SET_ENABLE_PCS_RESET = 48,
+	PHYTMAC_MSG_CMD_SET_DISABLE_PCS_RESET = 49,
+	PHYTMAC_MSG_CMD_SET_MDC = 50,
+	PHYTMAC_MSG_CMD_SET_OUTSTANDING = 51,
 };

 enum phytmac_get_subid {
@@ -278,6 +313,8 @@ enum phytmac_get_subid {
 	PHYTMAC_MSG_CMD_GET_BD_PREFETCH,
 	PHYTMAC_MSG_CMD_GET_STATS,
 	PHYTMAC_MSG_CMD_GET_REG_READ,
+	PHYTMAC_MSG_CMD_GET_RX_FLOW,
+	PHYTMAC_MSG_CMD_GET_REGS_FOR_ETHTOOL,
 };

 struct phytmac_interface_info {
@@ -292,6 +329,11 @@ struct phytmac_mc_info {
 	u32 mc_top;
 } __packed;

+struct phytmac_reg_info {
+	u32 offset;
+	u16 regnum;
+} __packed;
+
 struct phytmac_fdir_info {
 	u32 ip4src;
 	u32 ip4dst;
@@ -351,12 +393,26 @@ struct phytmac_feature {
 	u8 max_rx_fs;
 } __packed;

+struct phytmac_wol {
+	u32 wol_type;
+	u8 wake;
+} __packed;
+
 struct phytmac_msg_info {
-	u16 module_id;
-	u16 cmd_id;
-	u16 cmd_subid;
-	u16 flags;
+	u8 reserved;
+	u8 seq;
+	u8 cmd_type;
+	u8 cmd_subid;
+	u16 len;
+	u8 status1;
+	u8 status0;
 	u8 para[64];
 } __packed;

+struct phytmac_ots_config {
+	u32 axi_rd;
+	u32 axi_wr;
+	u8 queuenum;
+} __packed;
+
 #endif
--
2.50.1
