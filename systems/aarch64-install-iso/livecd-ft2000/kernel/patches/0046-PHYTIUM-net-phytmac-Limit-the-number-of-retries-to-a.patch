From 2ffb8cb59014fada1f224fdf6e627f12a08a58dd Mon Sep 17 00:00:00 2001
From: Li Wencheng <liwencheng@phytium.com.cn>
Date: Wed, 7 May 2025 17:22:13 +0800
Subject: [PATCH 46/67] PHYTIUM: net/phytmac: Limit the number of retries to
 avoid deadlock

It is need to limit retries that messages are processed
to avoid deadlock, when RV has no response.

Signed-off-by: Li Wencheng <liwencheng@phytium.com.cn>
Signed-off-by: Wang Yinfeng <wangyinfeng@phytium.com.cn>
Change-Id: Ic300b8c8544af91c62564caf538a2a2eb6c0b512

Link: https://gitee.com/phytium_embedded/phytium-linux-kernel/commit/d8fbda0b50a320673194e971fac55b6adbb2a85f
Signed-off-by: Kexy Biscuit <kexybiscuit@aosc.io>
---
 drivers/net/ethernet/phytium/phytmac_v2.c | 20 ++++++++++++++++++--
 drivers/net/ethernet/phytium/phytmac_v2.h |  2 ++
 2 files changed, 20 insertions(+), 2 deletions(-)

diff --git a/drivers/net/ethernet/phytium/phytmac_v2.c b/drivers/net/ethernet/phytium/phytmac_v2.c
index 65db2c0d15de..20c49bf5f4b8 100644
--- a/drivers/net/ethernet/phytium/phytmac_v2.c
+++ b/drivers/net/ethernet/phytium/phytmac_v2.c
@@ -25,6 +25,7 @@ static int phytmac_v2_msg_send(struct phytmac *pdata, u16 cmd_id,
 	u32 tx_head, tx_tail, ring_size;
 	struct phytmac_msg_info msg;
 	struct phytmac_msg_info msg_rx;
+	u32 retry = 0;
 	int ret = 0;

 	spin_lock(&pdata->msg_ring.msg_lock);
@@ -34,11 +35,19 @@ static int phytmac_v2_msg_send(struct phytmac *pdata, u16 cmd_id,
 	ring_size = pdata->msg_ring.tx_msg_ring_size;

 	while ((tx_tail + 1) % ring_size == tx_head) {
-		netdev_info(pdata->ndev, "Tx msg ring is overrun, tx_tail:0x%x, tx_head:0x%x",
-			    tx_tail, tx_head);
+		udelay(1);
 		tx_head = PHYTMAC_READ(pdata, PHYTMAC_TX_MSG_HEAD) & 0xff;
+		retry++;
+		if (retry >= PHYTMAC_RETRY_TIMES) {
+			netdev_err(pdata->ndev,
+				   "Time out waiting for Tx msg ring free, tx_tail:0x%x, tx_head:0x%x",
+				   tx_tail, tx_head);
+			spin_unlock(&pdata->msg_ring.msg_lock);
+			return -EINVAL;
+		}
 	}

+	retry = 0;
 	wait = 1;
 	memset(&msg, 0, sizeof(msg));
 	memset(&msg_rx, 0, sizeof(msg_rx));
@@ -66,7 +75,14 @@ static int phytmac_v2_msg_send(struct phytmac *pdata, u16 cmd_id,
 	if (wait) {
 		tx_head = PHYTMAC_READ(pdata, PHYTMAC_TX_MSG_HEAD) & 0xff;
 		while (tx_head != tx_tail) {
+			udelay(1);
 			tx_head = PHYTMAC_READ(pdata, PHYTMAC_TX_MSG_HEAD) & 0xff;
+			retry++;
+			if (retry >= PHYTMAC_RETRY_TIMES) {
+				netdev_err(pdata->ndev, "Msg process time out!");
+				spin_unlock(&pdata->msg_ring.msg_lock);
+				return -EINVAL;
+			}
 		}

 		memcpy(&msg_rx, pdata->msg_regs + PHYTMAC_MSG(pdata->msg_ring.tx_msg_rd_tail),
diff --git a/drivers/net/ethernet/phytium/phytmac_v2.h b/drivers/net/ethernet/phytium/phytmac_v2.h
index 4e195dcef04f..b32044d696ae 100644
--- a/drivers/net/ethernet/phytium/phytmac_v2.h
+++ b/drivers/net/ethernet/phytium/phytmac_v2.h
@@ -246,6 +246,8 @@ extern struct phytmac_hw_if phytmac_2p0_hw;
 #define PHYTMAC_CLK_DIV128	6
 #define PHYTMAC_CLK_DIV224	7

+#define PHYTMAC_RETRY_TIMES	50000
+
 #define PHYTMAC_READ_NSR(pdata)        PHYTMAC_READ(pdata, PHYTMAC_NETWORK_STATUS)

 enum phytmac_msg_cmd_id {
--
2.50.1
